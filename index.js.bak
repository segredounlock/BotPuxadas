// âš ï¸ Use por sua conta e risco
const { default: makeWASocket, DisconnectReason, makeInMemoryStore, jidDecode, Browsers, proto, getContentType, useMultiFileAuthState, downloadContentFromMessage } = require("@adiwajshing/baileys")
const chalk = require("chalk");
const axios = require("axios");
const fs = require("fs");
const path = require("path");
const config = require("./settings/config.json");
const GroupManager = require("./database/groupManager");

const globalConfig = {
  antilinkHard: false,
  welcomeEnabled: true
};








// Plataforma de API's


const API_KEY_TED = "Dragon250"



const apikey = "dragon21"


const site = "https://kayserapis.com"

const API_KEY_SHADOW = "Dragon2050"


const PNSPUXADA = "Nicolas";



const API_KEY_BRONXYS = "Pinterest";

const NomeDoBot = "ğ‘ºğ‘¬ğ‘®ğ‘¹ğ‘¬ğ‘«ğ‘¶ ğ‘·ğ‘¼ğ‘¿ğ‘¨ğ‘«ğ‘¨ğ‘º";


const API_KEY_ZEROTWO = "Chacal2025"


const SuaKey = "Chacal2025"




const API_KEY_MIWA = "sua key aqui"

var miwasite = "https://miwa-api.online"










// ===========================
// ğŸ›¡ï¸ SISTEMA ANTI-LINK
// ===========================

// Regex para detectar links
const linkRegex = /(https?:\/\/|wa\.me\/|chat\.whatsapp\.com\/|t\.me\/|discord\.gg\/)/i;

// FunÃ§Ã£o para verificar permissÃµes
async function getPermissions(sock, groupJid, participant, BOT_PHONE) {
  try {
    const metadata = await sock.groupMetadata(groupJid);
    const admins = metadata.participants
      .filter(p => p.admin !== null)
      .map(p => p.id);

    return {
      isAdmin: admins.includes(participant),
      isBotAdmin: admins.includes(BOT_PHONE + "@s.whatsapp.net"),
      isOwnerGroup: metadata.owner === participant,
      groupName: metadata.subject,
    };
  } catch (err) {
    console.log("Erro ao obter permissÃµes:", err);
    return { isAdmin: false, isBotAdmin: false, isOwnerGroup: false, groupName: "Grupo" };
  }
}

// FunÃ§Ã£o principal do anti-link
async function verificarMensagem(sock, from, msg, body, isGroup, BOT_PHONE) {
  if (!isGroup) return false; // SÃ³ funciona em grupos
  if (!body || !linkRegex.test(body)) return false; // Sem link, sai

  const participant = msg.key.participant || msg.key.remoteJid;
  const perms = await getPermissions(sock, from, participant, BOT_PHONE);

  // NÃ£o remove admins ou donos
  if (perms.isAdmin || perms.isOwnerGroup) return false;



  // Remove o usuÃ¡rio se o bot for admin
  if (perms.isBotAdmin) {
    try {
      // âš ï¸ Certifique-se de enviar **array de JIDs vÃ¡lidos** para remover
      await sock.groupParticipantsUpdate(from, [participant], "remove");
      console.log(`[ANTI-LINK] UsuÃ¡rio ${participant} removido do grupo ${perms.groupName}`);
      await sock.sendMessage(from, { text: "ğŸ”¨ *UsuÃ¡rio removido* por enviar link." });
    } catch (err) {
      console.log("Erro ao remover usuÃ¡rio:", err);
      await sock.sendMessage(from, {  })
    }
  } else {
    await sock.sendMessage(from, {  });
  }

  return true;
}

// ===========================
// ğŸ”¥ USO NO HANDLER
// ===========================

// Exemplo dentro do seu handler:
// const from = msg.key.remoteJid;
// const isGroup = from.endsWith("@g.us");
// const body = msg.message.conversation || msg.message.extendedTextMessage?.text || msg.message.imageMessage?.caption || msg.message.videoMessage?.caption || "";
// const BOT_PHONE = (sock?.user?.id || "").split(":")[0]?.replace(/[^0-9]/g, "");

// await verificarMensagem(sock, from, msg, body, isGroup, BOT_PHONE);

const botStart = Date.now(); 
const groupState = new Map();
const comandosOficiais = ["ping", "instagram", "status", "antilinkhard", "antilink", "ban", "welcome", "placa", "menu", "stats", "backup"];

const groupManager = new GroupManager();

// ==========================
// FunÃ§Ãµes auxiliares
// ==========================
function getTipoMensagem(msg) {
  if (msg.message?.stickerMessage) return "Figurinha";
  if (msg.message?.imageMessage) return "Imagem";
  if (msg.message?.videoMessage) return "VÃ­deo";
  if (msg.message?.audioMessage) return "Ãudio";
  if (msg.message?.documentMessage) return "Documento";
  return "Texto";
}

async function getPermissions(sock, groupJid, participant, BOT_PHONE) {
  try {
    const metadata = await sock.groupMetadata(groupJid);
    const admins = metadata.participants
      .filter(p => p.admin !== null)
      .map(p => p.id);

    return {
      isAdmin: admins.includes(participant),
      isBotAdmin: admins.includes(BOT_PHONE + "@s.whatsapp.net"),
      isOwnerGroup: metadata.owner === participant,
      groupName: metadata.subject,
    };
  } catch {
    return { isAdmin: false, isBotAdmin: false, isOwnerGroup: false, groupName: "Grupo" };
  }
}

function similaridade(str1, str2) {
  str1 = str1.toLowerCase();
  str2 = str2.toLowerCase();
  const match = [...str1].filter(char => str2.includes(char)).length;
  return (match * 2) / (str1.length + str2.length) * 100;
}


// ===========================
// ğŸ“Š LOG DE ATIVIDADES
// ===========================
function logActivity(type, details = {}) {
  const timestamp = new Date().toLocaleString('pt-BR');
  const logEntry = {
    timestamp,
    type,
    details
  };
  
  switch (type) {
    case 'MESSAGE_RECEIVED':
      console.log(`ğŸ“¨ [${timestamp}] Mensagem recebida`, details);
      break;
    case 'COMMAND_EXECUTED':
      console.log(`âš¡ [${timestamp}] Comando executado`, details);
      break;
    case 'ANTILINK_TRIGGERED':
      console.log(`ğŸš« [${timestamp}] Anti-link ativado`, details);
      break;
    case 'CONFIG_CHANGED':
      console.log(`âš™ï¸ [${timestamp}] ConfiguraÃ§Ã£o alterada`, details);
      break;
    default:
      console.log(`[${timestamp}] ${type}`, details);
  }
}






  /* ===========================
   ğŸ‰ SISTEMA DE BOAS-VINDAS
   =========================== */
// Objeto global para controlar cooldown por grupo
const welcomeCooldowns = {};

async function handleWelcome(sock, events) {
  if (!globalConfig.welcomeEnabled) return;

  if (events["group-participants"]?.update) {
    const update = events["group-participants"].update;
    const { action, participants, id } = update;

    if (action === "add") {

      // ğŸ”¹ Verifica cooldown do grupo
      const now = Date.now();
      if (welcomeCooldowns[id] && now - welcomeCooldowns[id] < 40000) {
        // Se ainda estiver no cooldown de 40s, nÃ£o envia nada
        return;
      }
      // Atualiza o cooldown
      welcomeCooldowns[id] = now;

      const metadata = await sock.groupMetadata(id);

      // ğŸ”¹ Array de mensagens de boas-vindas aleatÃ³rias
      const welcomeMessages = [
      "ğ‘ºğ’†ğ’‹ğ’‚ ğ’ğ’–ğ’Šğ’•ğ’ ğ‘©ğ’†ğ’ ğ‘½ğ’Šğ’ğ’…ğ’(ğ’‚), ğ’’ğ’–ğ’† ğ’”ğ’–ğ’‚ ğ’†ğ’”ğ’•ğ’‚ğ’…ğ’Šğ’‚ ğ’”ğ’†ğ’‹ğ’‚ ğ’Šğ’ğ’„ğ’“ğ’Šğ’—ğ’†ğ’! ğŸŒŸ",
      "ğŸ‘‹ ğ‘¶ğ’ğ’‚Ì! ğ’‘ğ’“ğ’†ğ’‘ğ’‚ğ’“ğ’†-ğ’”ğ’† ğ’‘ğ’‚ğ’“ğ’‚ ğ’ğ’” ğ’ğ’ğ’ğ’†ğ’ğ’•ğ’ğ’” ğ’…ğ’Šğ’—ğ’†ğ’“ğ’•ğ’Šğ’…ğ’ğ’” ğ’„ğ’ğ’ ğ’‚ ğ’ˆğ’‚ğ’ğ’†ğ’“ğ’‚!",
      "ğŸ‰ ğ‘ªğ’‰ğ’†ğ’ˆğ’ğ’– ğ’ğ’‚ğ’Šğ’” ğ’–ğ’ ğ’ğ’†ğ’ğ’ƒğ’“ğ’! ğ’’ğ’–ğ’† ğ’„ğ’ğ’ğ’†ğ’„ğ’† ğ’‚ ğ’…ğ’Šğ’—ğ’†ğ’“ğ’”ğ’‚ğ’!",
      "âœ¨ ğ‘©ğ’†ğ’ ğ’—ğ’Šğ’ğ’…ğ’(ğ’‚)! ğ‘¬ğ’”ğ’‘ğ’†ğ’“ğ’‚ğ’ğ’ğ’” ğ’’ğ’–ğ’† ğ’—ğ’„ ğ’„ğ’–ğ’“ğ’•ğ’‚ ğ’„ğ’‚ğ’…ğ’‚ ğ’ğ’ğ’ğ’†ğ’ğ’•ğ’ ğ’‚ğ’’ğ’–ğ’Š!",
      "ğŸ¤— ğ‘­ğ’Šğ’’ğ’–ğ’† ğ’‚ ğ’—ğ’ğ’ğ’•ğ’‚ğ’…ğ’†! ğ’‡ğ’‚ğ’„ğ’‚ ğ’‚ğ’ğ’Šğ’ˆğ’ğ’” ğ’† ğ’‚ğ’‘ğ’“ğ’ğ’—ğ’†ğ’Šğ’•ğ’† ğ’ ğ’ˆğ’“ğ’–ğ’‘ğ’!",
      "ğŸ” ğ‘ªğ’ğ’ğ’‰ğ’†ğ’„ğ’‚ ğ’ ğ’ğ’†ğ’ğ’‰ğ’ğ’“ ğ’ƒğ’ğ’• ğ’…ğ’† ğ’‘ğ’–ğ’™ğ’‚ğ’…ğ’‚ğ’” ğ’…ğ’ ğ’˜ğ’‰ğ’‚ğ’•ğ’”ğ’‚ğ’‘ğ’‘!",
      ];

      for (const participant of participants) {
        // ğŸ”¹ Nome de exibiÃ§Ã£o
        let userName;
        try {
          const contact = await sock.onWhatsApp(participant);
          userName = contact?.[0]?.notify || participant.split("@")[0];
        } catch {
          userName = participant.split("@")[0];
        }

        // ğŸ”¹ Imagem de perfil
        let profilePic;
        try {
          profilePic = await sock.profilePictureUrl(participant, "image");
        } catch {
          profilePic = "https://files.catbox.moe/9v8l6p.jpg";
        }

        // ğŸ”¹ Escolhe uma mensagem aleatÃ³ria
        const randomWelcome = welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];

        // ğŸ”¹ Monta a mensagem final
        const welcomeMsg = `à¼ºâ‹†â˜½Ëšâ˜ª *BEM-VINDO(A)* â˜ªËšâ˜½Ëšà¼»

â˜£ï¸ *${metadata.subject}* â˜£ï¸

âœ¨ OlÃ¡ *${userName}* (@${participant.split("@")[0]})!

${randomWelcome}

â•­â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
â”ƒ âœ› â˜¾ *ğšğ™´ğš‚ğ™¿ğ™´ğ™¸ğšƒğ™´ ğ™°ğš‚ ğšğ™´ğ™¶ğšğ™°ğš‚!* â˜½
â”ƒ âœ› â˜¾ *ğ™´ğš…ğ™¸ğšƒğ™´ ğ™´ğ™½ğš…ğ™¸ğ™°ğš ğ™»ğ™¸ğ™½ğ™ºğš‚!* â˜½
â”ƒ âœ› â˜¾ *ğš‚ğ™´ğ™¼ ğš‡ğ™¸ğ™½ğ™¶ğ™°ğ™¼ğ™´ğ™½ğšƒğ™¾ğš‚!* â˜½
â”ƒ âœ› â˜¾ *ğ™»ğ™´ğ™¸ğ™° ğ™° ğ™³ğ™´ğš‚ğ™²ğšğ™¸ğ™²ğ™°ğ™¾!* â˜½
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£                                             `;


        // ğŸ”¹ Envia imagem + legenda
        await sock.sendMessage(id, {
          image: { url: profilePic },
          caption: welcomeMsg,
          mentions: [participant]
        });

        // ğŸ”¹ Loga entrada do usuÃ¡rio
        logActivity('USER_JOINED', {
          groupName: metadata.subject,
          groupId: id,
          userId: participant
        });
      }

      // ğŸ”¹ Atualiza dados do grupo
      await groupManager.saveGroupData(sock, id, 'member_added');
    }
  }
}
// ==========================
// Comandos
// ==========================
async function handleCommand(sock, from, msg, command, args, ctx) {
  const { isGroup, BOT_PHONE } = ctx;
  if (!isGroup) return; // **bloqueia privados**

  const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);

  switch (command) {
case 'ANTILINK_TRIGGERED':
      console.log(chalk.hex('#FF4500').bold(`ğŸš« [${timestamp}] Anti-link ativado`));
      console.log(chalk.hex('#FF4500')(`   â””â”€ Grupo: ${details.groupName || 'Desconhecido'}`));
      console.log(chalk.hex('#FF4500')(`   â””â”€ AÃ§Ã£o: ${details.action}`));
      break;
   





//APIS PUXADAS//


   
      
    case 'cpf':
case 'cpf1': {
    const cpf = args[0]?.replace(/\D/g, '');

    if (!cpf || cpf.length !== 11) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um CPF vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}cpf51 12345678900`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando CPF ${cpf}... Aguarde!*`
        }, { quoted: msg });

        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/cpf?cpf=${encodeURIComponent(cpf)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o CPF informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« 
        const limparTexto = (texto) => {
            if (!texto) return '';

            return String(texto)
                
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')

                /
                .replace(/@\S+/g, '')

                // wa.me
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')

                // URLs genÃ©ricas
                .replace(/https?:\/\/\S+/gi, '')

                // espaÃ§os duplicados
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ†” *CONSULTA CPF* â¬£â”â”â”â•®
â”ƒ *CPF:* ${cpf}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar CPF.' },
            { quoted: msg }
        );
    }

    break;
}




case 'cnpj': {
    const cnpj = args[0]?.replace(/\D/g, '');

    if (!cnpj || cnpj.length !== 14) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um CNPJ vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}cnpj 12345678000195`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando CNPJ ${cnpj}... Aguarde!*`
        }, { quoted: msg });

        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/cnpj?cnpj=${encodeURIComponent(cnpj)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o CNPJ informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ¢ *CONSULTA CNPJ* â¬£â”â”â”â•®
â”ƒ *CNPJ:* ${cnpj}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar CNPJ.' },
            { quoted: msg }
        );
    }

    break;
}





case 'funcionarios': {
    const codigo = args[0]?.trim();

    if (!codigo) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o cÃ³digo ou matrÃ­cula do funcionÃ¡rio.\nğŸ“Œ Exemplo: ${config.prefix}funcionarios 12345`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando funcionÃ¡rio ${codigo}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (troque a URL pela real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/funcionarios?codigo=${encodeURIComponent(codigo)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o cÃ³digo informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ‘¤ *CONSULTA FUNCIONÃRIO* â¬£â”â”â”â•®
â”ƒ *CÃ“DIGO:* ${codigo}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar funcionÃ¡rio.' },
            { quoted: msg }
        );
    }

    break;
}






case 'socios': {
    const cnpj = args[0]?.replace(/\D/g, '');

    if (!cnpj || cnpj.length !== 14) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um CNPJ vÃ¡lido para consultar sÃ³cios.\nğŸ“Œ Exemplo: ${config.prefix}socios 12345678000195`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando sÃ³cios do CNPJ ${cnpj}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/socios?cnpj=${encodeURIComponent(cnpj)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhum sÃ³cio encontrado para o CNPJ informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n'); // separa sÃ³cios com espaÃ§o extra
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ‘¥ *SÃ“CIOS DO CNPJ* â¬£â”â”â”â•®
â”ƒ *CNPJ:* ${cnpj}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar sÃ³cios.' },
            { quoted: msg }
        );
    }

    break;
}




case 'email': {
    const email = args[0]?.trim();

    if (!email) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um email vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}email teste@dominio.com`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando email ${email}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/email?email=${encodeURIComponent(email)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o email informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£âœ‰ï¸ *CONSULTA EMAIL* â¬£â”â”â”â•®
â”ƒ *EMAIL:* ${email}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar email.' },
            { quoted: msg }
        );
    }

    break;
}




case 'nome': {
    const nome = args.join(' ').trim();

    if (!nome) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um nome vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}nome Italo Costa`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando nome "${nome}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/nome?nome=${encodeURIComponent(nome)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o nome informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n'); // separa resultados
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ“ *CONSULTA NOME* â¬£â”â”â”â•®
â”ƒ *NOME:* ${nome}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar nome.' },
            { quoted: msg }
        );
    }

    break;
}




case "abreviado": {
    const nome = args.join(" ").trim();

    if (!nome) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o nome para consulta abreviada.\nğŸ“Œ Exemplo: ${config.prefix}abreviado Italo Costa`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando nome abreviado: ${nome}... Aguarde!* ğŸ”`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/abreviado?abreviado=${encodeURIComponent(nome)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o nome informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n'); // separa resultados
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ“ *CONSULTA ABREVIADA* â¬£â”â”â”â•®
â”ƒ *NOME:* ${nome}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar nome abreviado.' },
            { quoted: msg }
        );
    }

    break;
}




case 'telefone': {
case 'tel': {
    const telefone = args[0]?.replace(/\D/g, '');

    if (!telefone || telefone.length < 10) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um nÃºmero de telefone vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}telefone 11987654321`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando telefone ${telefone}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/telefone?telefone=${encodeURIComponent(telefone)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o telefone informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ“ *CONSULTA TELEFONE* â¬£â”â”â”â•®
â”ƒ *TELEFONE:* ${telefone}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar telefone.' },
            { quoted: msg }
        );
    }

    break;
}



case 'rg': {
    const rg = args[0]?.replace(/\D/g, '');

    if (!rg || rg.length < 5) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um RG vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}rg 123456789`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando RG ${rg}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/rg?rg=${encodeURIComponent(rg)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o RG informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ†” *CONSULTA RG* â¬£â”â”â”â•®
â”ƒ *RG:* ${rg}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar RG.' },
            { quoted: msg }
        );
    }

    break;
}



case 'cnh': {
    const cnh = args[0]?.replace(/\D/g, '');

    if (!cnh || cnh.length < 10) {
        return sock.sendMessage(from, {
            text: `âŒ Informe uma CNH vÃ¡lida.\nğŸ“Œ Exemplo: ${config.prefix}cnh 12345678901`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando CNH ${cnh}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/cnh?cpf=${encodeURIComponent(cnh)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para a CNH informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸš— *CONSULTA CNH* â¬£â”â”â”â•®
â”ƒ *CNH:* ${cnh}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar CNH.' },
            { quoted: msg }
        );
    }

    break;
}



case 'obito': {
    const query = args.join(' ').trim();

    if (!query) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o nome ou CPF para consulta de Ã³bito.\nğŸ“Œ Exemplo: ${config.prefix}obito Italo Costa`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando Ã³bito para "${query}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/obito?obito=${encodeURIComponent(query)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhum registro de Ã³bito encontrado para a consulta informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n'); // separa resultados
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£âš°ï¸ *CONSULTA Ã“BITO* â¬£â”â”â”â•®
â”ƒ *CONSULTA:* ${query}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar Ã³bito.' },
            { quoted: msg }
        );
    }

    break;
}





case 'nis': {
    const nis = args[0]?.replace(/\D/g, '');

    if (!nis || nis.length < 10) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um NIS vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}nis 12345678901`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando NIS ${nis}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/nis?nis=${encodeURIComponent(nis)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o NIS informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ†” *CONSULTA NIS* â¬£â”â”â”â•®
â”ƒ *NIS:* ${nis}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar NIS.' },
            { quoted: msg }
        );
    }

    break;
}




case 'pis': {
    const pis = args[0]?.replace(/\D/g, '');

    if (!pis || pis.length < 10) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um nÃºmero PIS vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}pis 12345678901`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando PIS ${pis}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/pis?pis=${encodeURIComponent(pis)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o PIS informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ†” *CONSULTA PIS* â¬£â”â”â”â•®
â”ƒ *PIS:* ${pis}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar PIS.' },
            { quoted: msg }
        );
    }

    break;
}




case 'vacinas': {
    const cpf = args[0]?.replace(/\D/g, '');

    if (!cpf || cpf.length !== 11) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um CPF vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}vacinas 12345678900`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ’‰ *Consultando vacinas para CPF ${cpf}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/vacinas?vacinas=${encodeURIComponent(cpf)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o de vacinas encontrada para o CPF informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ’‰ *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ’‰ *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ’‰ *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ’‰ *CONSULTA VACINAS* â¬£â”â”â”â•®
â”ƒ *CPF:* ${cpf}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar vacinas.' },
            { quoted: msg }
        );
    }

    break;
}




case 'renavam': {
    const renavam = args[0]?.replace(/\D/g, '');

    if (!renavam || renavam.length < 9) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um RENAVAM vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}renavam 12345678901`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸš— *Consultando RENAVAM ${renavam}... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/renavam?renavam=${encodeURIComponent(renavam)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o RENAVAM informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸš— *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸš— *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸš— *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸš— *CONSULTA RENAVAM* â¬£â”â”â”â•®
â”ƒ *RENAVAM:* ${renavam}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar RENAVAM.' },
            { quoted: msg }
        );
    }

    break;
}




case 'parentes': {
    const query = args.join(' ').trim();

    if (!query) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o nome ou CPF para consulta de parentes.\nğŸ“Œ Exemplo: ${config.prefix}parentes Italo Costa`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ” *Consultando parentes para "${query}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/parentes?parentes=${encodeURIComponent(query)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhum registro de parentes encontrado para a consulta informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Remove linhas vazias
        const limparLinha = l => l && l.trim() !== '';

        // ğŸš« Limpeza de texto
        const limparTexto = (texto) => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ” *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n'); // separa resultados
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ” *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';

                        return `ğŸ” *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ‘ª *CONSULTA PARENTES* â¬£â”â”â”â•®
â”ƒ *CONSULTA:* ${query}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `
        .trim()
        .replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar parentes.' },
            { quoted: msg }
        );
    }

    break;
}




case 'mae': {
    const query = args.join(' ').trim();

    if (!query) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o nome ou CPF para consulta da mÃ£e.\nğŸ“Œ Exemplo: ${config.prefix}mae Italo Costa`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ‘©â€ğŸ‘¦ *Consultando mÃ£e para "${query}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/mae?mae=${encodeURIComponent(query)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhum registro de mÃ£e encontrado para a consulta informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Limpeza de linhas
        const limparLinha = l => l && l.trim() !== '';
        const limparTexto = texto => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ‘©â€ğŸ‘¦ *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                // Filtra apenas mÃ£e
                const mae = obj.filter(i => i.parentesco?.toLowerCase() === 'mÃ£e');
                if (!mae.length) return 'âŒ Nenhum registro de mÃ£e encontrado.';
                return mae
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ‘©â€ğŸ‘¦ *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';
                        return `ğŸ‘©â€ğŸ‘¦ *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ‘©â€ğŸ‘¦ *CONSULTA MÃƒE* â¬£â”â”â”â•®
â”ƒ *CONSULTA:* ${query}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `.trim().replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar mÃ£e.' },
            { quoted: msg }
        );
    }

    break;
}





case 'pai': {
    const query = args.join(' ').trim();

    if (!query) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o nome ou CPF para consulta do pai.\nğŸ“Œ Exemplo: ${config.prefix}pai Italo Costa`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ‘¨â€ğŸ‘¦ *Consultando pai para "${query}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/pai?pai=${encodeURIComponent(query)}`
        );
        const data = await response.json();

        if (!data?.data || !data.data.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhum registro de pai encontrado para a consulta informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        // ğŸ§¹ Limpeza de linhas
        const limparLinha = l => l && l.trim() !== '';
        const limparTexto = texto => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        // ğŸ” FORMATADOR RECURSIVO LIMPO
        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ‘¨â€ğŸ‘¦ *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                // Filtra apenas pai
                const pai = obj.filter(i => i.parentesco?.toLowerCase() === 'pai');
                if (!pai.length) return 'âŒ Nenhum registro de pai encontrado.';
                return pai
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ‘¨â€ğŸ‘¦ *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';
                        return `ğŸ‘¨â€ğŸ‘¦ *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ‘¨â€ğŸ‘¦ *CONSULTA PAI* â¬£â”â”â”â•®
â”ƒ *CONSULTA:* ${query}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `.trim().replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar pai.' },
            { quoted: msg }
        );
    }

    break;
}



case 'placa': {
    const placa = args[0]?.toUpperCase().trim();

    if (!placa) {
        return sock.sendMessage(from, {
            text: `âŒ Informe a placa do veÃ­culo.\nğŸ“Œ Exemplo: ${config.prefix}placa ABC1234`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸš— *Consultando veÃ­culo da placa "${placa}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/placa?placa=${encodeURIComponent(placa)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para a placa informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        const limparLinha = l => l && l.trim() !== '';
        const limparTexto = texto => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸš— *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸš— *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';
                        return `ğŸš— *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸš— *CONSULTA PLACA* â¬£â”â”â”â•®
â”ƒ *PLACA:* ${placa}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `.trim().replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar a placa.' },
            { quoted: msg }
        );
    }

    break;
}



case 'chassi': {
    const chassi = args[0]?.toUpperCase().trim();

    if (!chassi) {
        return sock.sendMessage(from, {
            text: `âŒ Informe o nÃºmero do chassi.\nğŸ“Œ Exemplo: ${config.prefix}chassi 9BWZZZ377VT004251`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸš˜ *Consultando veÃ­culo pelo chassi "${chassi}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/chassi?chassi=${encodeURIComponent(chassi)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o chassi informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        const limparLinha = l => l && l.trim() !== '';
        const limparTexto = texto => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸš˜ *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸš˜ *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';
                        return `ğŸš˜ *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸš˜ *CONSULTA CHASSI* â¬£â”â”â”â•®
â”ƒ *CHASSI:* ${chassi}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `.trim().replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar chassi.' },
            { quoted: msg }
        );
    }

    break;
}





case 'bin': {
    const bin = args[0]?.trim();

    if (!bin) {
        return sock.sendMessage(from, {
            text: `âŒ Informe um BIN vÃ¡lido.\nğŸ“Œ Exemplo: ${config.prefix}bin 552879`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ’³ *Consultando BIN "${bin}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/bin?bin=${encodeURIComponent(bin)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para o BIN informado.`
            }, { quoted: msg, edit: carregando.key });
        }

        const limparLinha = l => l && l.trim() !== '';
        const limparTexto = texto => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ’³ *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ’³ *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';
                        return `ğŸ’³ *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ’³ *CONSULTA BIN* â¬£â”â”â”â•®
â”ƒ *BIN:* ${bin}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `.trim().replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar BIN.' },
            { quoted: msg }
        );
    }

    break;
}






case "placa2": {
    const text = args.join(" ").trim();

    if (!text) {
        return sock.sendMessage(from, {
            text: `Use assim:\n${config.prefix}placa3 PIF4883`
        }, { quoted: msg });
    }

    const placa = text.replace(/[^A-Za-z0-9]/g, "").toUpperCase();
    if (placa.length < 7) {
        return sock.sendMessage(from, {
            text: "âŒ Placa invÃ¡lida."
        }, { quoted: msg });
    }

    const carregando = await sock.sendMessage(from, {
        text: `Consultando placa ${placa}, aguarde...`
    }, { quoted: msg });

    try {
        const res = await axios.get(`http://node.tconect.xyz:3029/placa1?placa=${placa}`);
        const dados = res.data?.data?.resposta || res.data;

        if (!dados) {
            return sock.sendMessage(from, {
                text: "âŒ Nenhum resultado encontrado."
            }, { quoted: msg, edit: carregando.key });
        }

        function formatarConsultaPlaca(texto) {
            let t = typeof texto === "string" ? texto : JSON.stringify(texto);

            t = t
                .replace(/[{}î€î€"]/g, "")
                .replace(/\bCopiar\b/gi, "")
                .replace(/https?:\/\/\S+/gi, "")
                .replace(/\r/g, "")
                .replace(/\s{2,}/g, " ");

            t = t.replace(/([A-ZÃÃ‰ÃÃ“ÃšÃ‚ÃŠÃ”ÃƒÃ•Ã‡\/\s]{3,}):/g, "\n$1:");

            t = t
                .replace(/PLACA\s*:/gi, "\nPLACA:")
                .replace(/MARCA\s*\/\s*MODELO\s*:/gi, "\nMARCA / MODELO:")
                .replace(/CHASSI\s*:/gi, "\nCHASSI:")
                .replace(/RENAVAM\s*:/gi, "\nRENAVAM:")
                .replace(/MOTOR\s*:/gi, "\nMOTOR:")
                .replace(/COR\s*:/gi, "\nCOR:")
                .replace(/CATEGORIA\s*:/gi, "\nCATEGORIA:")
                .replace(/TIPO VE[IÃ]CULO\s*:/gi, "\nTIPO VEÃCULO:")
                .replace(/ESP[EÃ‰]CIE\s*:/gi, "\nESPÃ‰CIE:")
                .replace(/COMBUST[IÃ]VEL\s*:/gi, "\nCOMBUSTÃVEL:")
                .replace(/ANO MODELO\s*:/gi, "\nANO MODELO:")
                .replace(/ANO FABRICAÃ‡ÃƒO\s*:/gi, "\nANO FABRICAÃ‡ÃƒO:")
                .replace(/CARROCERIA\s*:/gi, "\nCARROCERIA:")
                .replace(/CÃ‚MBIO\s*:/gi, "\nCÃ‚MBIO:")
                .replace(/SITUAÃ‡ÃƒO DO VE[IÃ]CULO/gi, "\nSITUAÃ‡ÃƒO DO VEÃCULO")
                .replace(/SITUAÃ‡ÃƒO\s*:/gi, "\nSITUAÃ‡ÃƒO:")
                .replace(/LICENCIADO\s*:/gi, "\nLICENCIADO:")
                .replace(/ALERTA\s*:/gi, "\nALERTA:")
                .replace(/PROPRIET[AÃ]RIO/gi, "\nPROPRIETÃRIO")
                .replace(/NOME\s*:/gi, "\nNOME:")
                .replace(/CPF\s*:/gi, "\nCPF:")
                .replace(/HABILITADO PARA DIRIGIR\s*:/gi, "\nHABILITADO PARA DIRIGIR:")
                .replace(/ENDEREÃ‡O/gi, "\nENDEREÃ‡O")
                .replace(/RUA\s*:/gi, "\nRUA:")
                .replace(/NÃšMERO\s*:/gi, "\nNÃšMERO:")
                .replace(/COMPLEMENTO\s*:/gi, "\nCOMPLEMENTO:")
                .replace(/BAIRRO\s*:/gi, "\nBAIRRO:")
                .replace(/CIDADE\s*:/gi, "\nCIDADE:")
                .replace(/ESTADO\s*:/gi, "\nESTADO:")
                .replace(/CEP\s*:/gi, "\nCEP:")
                .replace(/DÃ‰BITOS/gi, "\nDÃ‰BITOS")
                .replace(/IPVA\s*:/gi, "\nIPVA:")
                .replace(/LICENCIAMENTO\s*:/gi, "\nLICENCIAMENTO:")
                .replace(/SEGURO\s*:/gi, "\nSEGURO:")
                .replace(/SERVIÃ‡O\s*:/gi, "\nSERVIÃ‡O:")
                .replace(/MULTAS\s*:/gi, "\nMULTAS:")
                .replace(/TOTAL DE DÃ‰BITOS\s*:/gi, "\nTOTAL DE DÃ‰BITOS:");

            let linhas = t
                .split("\n")
                .map(l => l.trim())
                .filter(l =>
                    l &&
                    !l.includes("DATA/HORA DA CONSULTA") &&
                    !l.includes("QUERY FORNECIDA") &&
                    !l.includes("API UTILIZADA") &&
                    !l.includes("ENDPOINT") &&
                    !l.includes("DFENDPOINT") &&
                    !l.includes("PARÃ‚METRO UTILIZADO") &&
                    !l.includes("INFORMAÃ‡Ã•ES DA CONSULTA") &&
                    !l.includes("fonte:") &&
                    !l.includes("url:")
                );

            let resultado = [];
            for (let i = 0; i < linhas.length; i++) {
                const atual = linhas[i];
                const prox = linhas[i + 1];

                if (atual.endsWith(":") && prox && !prox.endsWith(":")) {
                    resultado.push(`*${atual}*  *${prox}*`);
                    i++;
                } else {
                    resultado.push(`*${atual}*`);
                }
            }

            return Array.from(new Set(resultado));
        }

        const linhas = [
            `*CONSULTA_PLACA*,`,
            `*"placa": "${placa}"*,`,
            ...formatarConsultaPlaca(dados)
        ];

        const resultado = `
â•­â”â”â”â¬£ CONSULTA PLACA - ${config.NomeDoBot} â¬£â”â”â”â•®
â”ƒ PLACA: ${placa}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”ƒ
${linhas.map(l => `â”ƒ  ${l}`).join("\n")}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯
        `.trim();

        await sock.sendMessage(from, {
            text: resultado
        }, { quoted: msg, edit: carregando.key });

    } catch (err) {
        console.error(err);
        await sock.sendMessage(from, {
            text: "âŒ Erro ao consultar placa."
        }, { quoted: msg });
    }

    break;
}


case 'pix': {
    const chavePix = args.join(' ').trim();

    if (!chavePix) {
        return sock.sendMessage(from, {
            text: `âŒ Informe a chave PIX para consulta.\nğŸ“Œ Exemplo: ${config.prefix}pix italo@email.com`
        }, { quoted: msg });
    }

    try {
        const carregando = await sock.sendMessage(from, {
            text: `ğŸ’¸ *Consultando PIX "${chavePix}"... Aguarde!*`
        }, { quoted: msg });

        // ğŸ”— Consulta API (substitua pela URL real)
        const response = await fetch(
            `http://nxf-2.nexfuture.com.br:25589/pix?pix=${encodeURIComponent(chavePix)}`
        );
        const data = await response.json();

        if (!data?.data) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma informaÃ§Ã£o encontrada para a chave PIX informada.`
            }, { quoted: msg, edit: carregando.key });
        }

        const limparLinha = l => l && l.trim() !== '';
        const limparTexto = texto => {
            if (!texto) return '';
            return String(texto)
                .replace(/https?:\/\/t\.me\/\S+/gi, '')
                .replace(/\bt\.me\/\S+/gi, '')
                .replace(/@\S+/g, '')
                .replace(/https?:\/\/wa\.me\/\S+/gi, '')
                .replace(/https?:\/\/\S+/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        };

        const formatarBlocos = (obj, nivel = 0) => {
            if (nivel > 6 || obj == null) return '';

            if (typeof obj === 'string' || typeof obj === 'number') {
                return limparTexto(obj)
                    .split('\n')
                    .map(l => l.trim())
                    .filter(limparLinha)
                    .map(l => `ğŸ’¸ *${l}*`)
                    .join('\n');
            }

            if (Array.isArray(obj)) {
                return obj
                    .map(i => formatarBlocos(i, nivel + 1))
                    .filter(Boolean)
                    .join('\n\n');
            }

            if (typeof obj === 'object') {
                return Object.entries(obj)
                    .map(([k, v]) => {
                        const chave = k.replace(/_/g, ' ').toUpperCase();

                        if (typeof v === 'object') {
                            const bloco = formatarBlocos(v, nivel + 1);
                            return bloco ? `ğŸ’¸ *${chave}:*\n${bloco}` : '';
                        }

                        const valorLimpo = limparTexto(v);
                        if (!limparLinha(valorLimpo)) return '';
                        return `ğŸ’¸ *${chave}:* *${valorLimpo || 'SEM INFORMAÃ‡ÃƒO'}*`;
                    })
                    .filter(Boolean)
                    .join('\n');
            }

            return '';
        };

        const resultado = `
â•­â”â”â”â¬£ğŸ’¸ *CONSULTA PIX* â¬£â”â”â”â•®
â”ƒ *CHAVE PIX:* ${chavePix}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${formatarBlocos(data.data)
    .split('\n')
    .map(l => `â”ƒ ${l}`)
    .join('\n')}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
        `.trim().replace(/\n{3,}/g, '\n\n');

        await sock.sendMessage(
            from,
            { text: resultado },
            { quoted: msg, edit: carregando.key }
        );

    } catch (err) {
        console.error(err);
        await sock.sendMessage(
            from,
            { text: 'âŒ Erro ao consultar PIX.' },
            { quoted: msg }
        );
    }

    break;
}





case "score": {
    const text = args.join(" ").trim();

    if (!text) {
        return sock.sendMessage(from, {
            text: `Use assim:\n${config.prefix}score 17168554204`
        }, { quoted: msg });
    }

    const cpf = text.replace(/\D/g, "");
    if (cpf.length !== 11) {
        return sock.sendMessage(from, {
            text: "âŒ CPF invÃ¡lido."
        }, { quoted: msg });
    }

    const carregando = await sock.sendMessage(from, {
        text: `Consultando SCORE do CPF ${cpf}, aguarde...`
    }, { quoted: msg });

    try {
        const res = await axios.get(`http://node.tconect.xyz:3029/score?cpf=${cpf}`);
        const dados = res.data?.data?.resposta || res.data;

        if (!dados) {
            return sock.sendMessage(from, {
                text: "âŒ Nenhum resultado encontrado."
            }, { quoted: msg, edit: carregando.key });
        }

        function formatarConsultaScore(texto) {
            let t = typeof texto === "string" ? texto : JSON.stringify(texto);

            t = t
                .replace(/https?:\/\/\S+/gi, "")
                .replace(/Copiar/gi, "")
                .replace(/\\n|\\r|\\t/gi, "\n")
                .replace(/[{}\[\]"]/g, "")
                .replace(/\r/g, "")
                .replace(/\s{2,}/g, " ")
                .toUpperCase();

            t = t
                .replace(/SCORE SERASA/gi, "\nSCORE SERASA")
                .replace(/SCORE CSB/gi, "\nSCORE CSB:")
                .replace(/FAIXA DE RISCO CSB/gi, "\nFAIXA DE RISCO CSB:")
                .replace(/SCORE CSBA/gi, "\nSCORE CSBA:")
                .replace(/FAIXA DE RISCO CSBA/gi, "\nFAIXA DE RISCO CSBA:")
                .replace(/CLASSIFICACAO/gi, "\nCLASSIFICACAO:")
                .replace(/CSB:\s*/gi, "\nCSB: ");

            let linhas = t
                .split("\n")
                .map(l => l.trim())
                .filter(l =>
                    l &&
                    !l.includes("URL") &&
                    !l.includes("CPF") &&
                    !l.includes("NOME") &&
                    !l.includes("ATUALIZADO")
                );

            let resultado = [];
            for (let i = 0; i < linhas.length; i++) {
                const atual = linhas[i];
                const prox = linhas[i + 1];

                if (atual.endsWith(":") && prox && !prox.endsWith(":")) {
                    resultado.push(`*${atual}*  *${prox}*`);
                    i++;
                } else {
                    resultado.push(`*${atual}*`);
                }
            }

            return Array.from(new Set(resultado));
        }

        const linhas = [
            `*CONSULTA_SCORE*,`,
            `*"cpf": "${cpf}"*,`,
            ...formatarConsultaScore(dados)
        ];

        const resultado = `
â•­â”â”â”â¬£ CONSULTA SCORE - ${config.NomeDoBot} â¬£â”â”â”â•®
â”ƒ CPF: ${cpf}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”ƒ
${linhas.map(l => `â”ƒ  ${l}`).join("\n")}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯
        `.trim();

        await sock.sendMessage(from, {
            text: resultado
        }, { quoted: msg, edit: carregando.key });

    } catch (err) {
        console.error(err);
        await sock.sendMessage(from, {
            text: "âŒ Erro ao consultar SCORE."
        }, { quoted: msg });
    }

    break;
}            
               
                  
                     
                        
                           
                              
                                    


///////////////////=


case "perfil": {
    if (!msg.isGroup) {
        return sock.sendMessage(
            from,
            { text: "âŒ Este comando sÃ³ pode ser usado em grupos." },
            { quoted: msg }
        );
    }

    try {
        const groupMetadata = await sock.groupMetadata(from);
        const participants = groupMetadata.participants;

        const userId = msg.sender;
        const autor = participants.find(p => p.id === userId);
        const nickUsuario = autor?.pushname || msg.pushName || "Sem Nick";
        const numero = userId.split("@")[0];

        const isAdmin = autor?.admin === "admin";
        const isOwner = autor?.admin === "superadmin";
        const hierarquia = isOwner ? "ğŸ‘‘ Dono do Grupo" : isAdmin ? "â­ Admin do Grupo" : "ğŸ‘¤ Membro";
        const membroDesde = autor?.joinedTimestamp ? new Date(autor.joinedTimestamp).toLocaleDateString() : "Desconhecido";

        // Valores aleatÃ³rios
        const nivelGado = Math.floor(Math.random() * 101);
        const nivelPuta = Math.floor(Math.random() * 101);
        const nivelGostosura = Math.floor(Math.random() * 101);
        const inteligencia = Math.floor(Math.random() * 101);
        const programa = Math.floor(Math.random() * 401) + 100;
        const nivel = Math.floor(Math.random() * 5) + 1;
        const medalhas = nivel >= 5 ? "ğŸ…ğŸ…ğŸ…" : nivel >= 3 ? "ğŸ…ğŸ…" : "ğŸ…";
        const mensagens = Math.floor(Math.random() * 451) + 50;
        const comandosUsados = Math.floor(Math.random() * 91) + 10;
        const reports = Math.floor(Math.random() * 6);

        // Frases divertidas
        const gadoFrase = nivelGado > 80 ? "ğŸ‚ Extremamente Gado" : nivelGado > 50 ? "ğŸ‚ Gado mÃ©dio" : "ğŸ‚ Baixo nÃ­vel de Gado";
        const putaFrase = nivelPuta > 80 ? "ğŸ˜ˆ Safad@ master" : nivelPuta > 50 ? "ğŸ˜ˆ Um pouco safad@" : "ğŸ˜‡ Quase anjo";
        const gostosuraFrase = nivelGostosura > 80 ? "ğŸ¥µ Que gostosur@!" : nivelGostosura > 50 ? "ğŸ¥µ Bem atraente" : "ğŸ™‚ Bonit@";
        const inteligenciaFrase = inteligencia > 80 ? "ğŸ§  GÃªnio" : inteligencia > 50 ? "ğŸ§  Inteligente" : "ğŸ§  Precisa estudar mais";

        // Conselhos/memes aleatÃ³rios
        const conselhos = [
            'ğŸ’¬ â€œNÃ£o se preocupe, ninguÃ©m Ã© perfeitoâ€¦ exceto eu ğŸ˜â€',
            'ğŸ’¬ â€œSe a vida te der limÃµes, peÃ§a sal e tequila ğŸ‹â€',
            'ğŸ’¬ â€œCuidado com quem te critica, eles tambÃ©m erram ğŸ¤¡â€',
            'ğŸ’¬ â€œSorria, amanhÃ£ pode ser pior ğŸ˜…â€',
            'ğŸ’¬ â€œA preguiÃ§a Ã© minha amiga fiel ğŸ›Œâ€',
            'ğŸ’¬ â€œSeja vocÃª mesmoâ€¦ a menos que possa ser um dragÃ£o ğŸ‰â€'
        ];
        const conselhoAleatorio = conselhos[Math.floor(Math.random() * conselhos.length)];

        // PresenÃ§a e dispositivos
        let presenca = "Desconhecido";
        let dispositivos = [];

        try {
            const presence = await sock.presenceSubscribe(userId);

            if (presence?.lastSeen) {
                presenca = `ğŸ•’ Ãšltimo visto: ${new Date(presence.lastSeen).toLocaleString()}`;
            } else if (presence?.chatstate === "composing") {
                presenca = "âœï¸ Digitando...";
            } else {
                presenca = "âœ… Online";
            }

            const platforms = presence?.platform || presence?.device || [];
            const listaPlataformas = Array.isArray(platforms) ? platforms : [platforms];

            for (let p of listaPlataformas) {
                switch (p) {
                    case "android": dispositivos.push("ğŸ“± Android"); break;
                    case "ios": dispositivos.push("ğŸ“± iPhone"); break;
                    case "web": dispositivos.push("ğŸ’» WhatsApp Web"); break;
                    case "ipad": dispositivos.push("ğŸ“± iPad"); break;
                    case "desktop": dispositivos.push("ğŸ’» Desktop"); break;
                    default: dispositivos.push("Desconhecido"); break;
                }
            }

            if (dispositivos.length === 0) dispositivos.push("Desconhecido");

        } catch {
            presenca = "âŒ Offline ou invisÃ­vel";
            dispositivos.push("Desconhecido");
        }

        // Avatar HD
        let profilePic = "https://i.imgur.com/2yaf2wb.png";
        try {
            profilePic = await sock.profilePictureUrl(userId, "image");
        } catch {}

        // Ãšltimo recado/status
        let statusMsg = "Sem recado";
        try {
            const status = await sock.getStatus(userId);
            if (status?.status) statusMsg = status.status;
        } catch {}

        // Monta a mensagem super divertida
        const perfil = {
            image: { url: profilePic },
            caption: `
â•­â”€â”â”â”â”â”â”âŠ± ã€˜ âœ¨ SEU PERFIL âœ¨ ã€™âŠ°â”â”â”â”â”â”â”€â•®
â”‚
â”œ ğŸ­ *Nome*: ${nickUsuario}
â”œ ğŸ“ *WhatsApp*: +${numero}
â”œ ğŸ‚ *NÃ­vel Gado*: ${nivelGado}% â€” ${gadoFrase}
â”œ ğŸ˜ˆ *NÃ­vel Puta*: ${nivelPuta}% â€” ${putaFrase}
â”œ ğŸ¥µ *NÃ­vel Gostosura*: ${nivelGostosura}% â€” ${gostosuraFrase}
â”œ ğŸ§  *InteligÃªncia*: ${inteligencia}% â€” ${inteligenciaFrase}
â”œ ğŸ¼ *Programa*: R$${programa}
â”œ ğŸ“… *Membro desde*: ${membroDesde}
â”œ ${presenca}
â”œ ğŸ“± *Dispositivo*: ${dispositivos.join(", ")}
â”œ âš¡ *Comandos usados*: ${comandosUsados}
â”œ ğŸ’¬ *Mensagens enviadas*: ${mensagens}
â”œ âš ï¸ *Reports recebidos*: ${reports}
â”œ ğŸ… *Medalhas*: ${medalhas}
â”œ ğŸ“ *Recado*: ${statusMsg}
â”œ ${hierarquia}
â”œ ğŸ”® *Conselho do dia*: ${conselhoAleatorio}
â•°â”€â”â”â”â”â”â”âŠ± ã€˜ ğŸ’¡ BOT DRAGON ğŸ’¡ ã€™âŠ°â”â”â”â”â”â”â”€â•¯
            `
        };

        await sock.sendMessage(from, perfil, { quoted: msg });

    } catch (err) {
        console.error(err);
        await sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao buscar o perfil." }, { quoted: msg });
    }
    break;
}





case "hentaihd": {
    try {
        const cheerio = require("cheerio");

        // ğŸ”¹ Fetch universal (Node 16, 18+, Termux, VPS)
        const fetch = global.fetch
            ? global.fetch
            : (...args) => import("node-fetch").then(({ default: fetch }) => fetch(...args));

        // Termo digitado
        const termo = args.length ? args.join("_").toLowerCase() : "";
        if (!termo) {
            return sock.sendMessage(from, {
                text: `âŒ Informe a tag desejada.\nğŸ“Œ Exemplo: ${config.prefix}hentaihd neko`
            }, { quoted: msg });
        }

        // Mensagem de carregamento
        const carregando = await sock.sendMessage(from, {
            text: `â³ Buscando hentai HD com a tag *${termo}*...`
        }, { quoted: msg });

        // Headers completos (Cloudflare friendly)
        const headers = {
            "User-Agent":
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.9",
            "Connection": "keep-alive"
        };

        // URL de busca
        const url = `https://rule34.xxx/index.php?page=post&s=list&tags=${encodeURIComponent(termo)}`;
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error("Falha ao acessar Rule34");

        const html = await res.text();
        const $ = cheerio.load(html);

        // Captura links dos posts
        const postLinks = [];
        $("span.thumb > a").each((_, el) => {
            const href = $(el).attr("href");
            if (href) postLinks.push(`https://rule34.xxx/${href}`);
        });

        if (postLinks.length === 0) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma imagem encontrada para *${termo}*`
            }, { quoted: msg, edit: carregando.key });
        }

        // Escolhe post aleatÃ³rio
        const randomPost = postLinks[Math.floor(Math.random() * postLinks.length)];

        // Busca pÃ¡gina do post
        const resPost = await fetch(randomPost, { headers });
        const htmlPost = await resPost.text();
        const $$ = cheerio.load(htmlPost);

        let hdImage = $$("img#image").attr("src");
        if (!hdImage) throw new Error("Imagem nÃ£o encontrada");

        if (!hdImage.startsWith("http")) {
            hdImage = "https:" + hdImage;
        }

        // Envia imagem
        await sock.sendMessage(from, {
            image: { url: hdImage },
            caption: `ğŸ‘ *Hentai HD*\nğŸ” Tag: ${termo}\nğŸ“¦ Fonte: Rule34`
        }, { quoted: msg, edit: carregando.key });

    } catch (err) {
        console.error("Erro hentaihd:", err);
        await sock.sendMessage(from, {
            text: "âŒ Erro ao buscar hentai HD. Tente novamente mais tarde."
        }, { quoted: msg });
    }
    break;
}

case "hentaihd2": {
    try {
        const cheerio = require("cheerio");

        // ğŸ”¹ Fetch universal (Node 16, 18+, Termux, VPS, Docker)
        const fetch = global.fetch
            ? global.fetch
            : (...args) => import("node-fetch").then(({ default: fetch }) => fetch(...args));

        const user = msg.key.participant || msg.key.remoteJid;
        const username = user === msg.sender ? "VocÃª" : `@${user.split("@")[0]}`;

        if (!args.length) {
            return sock.sendMessage(from, {
                text: `âŒ Por favor, digite o nome do hentai.\nğŸ“Œ Ex: ${config.prefix}hentaihd2 naruto`
            }, { quoted: msg });
        }

        const termo = args.join("_").toLowerCase();
        let postLinks = [];
        const maxPages = 5;
        let page = 0;

        // Headers completos (Cloudflare friendly)
        const headers = {
            "User-Agent":
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.9",
            "Connection": "keep-alive"
        };

        // Mensagem de carregamento
        const carregando = await sock.sendMessage(from, {
            text: `â³ Buscando hentai HD/4K com a tag *${termo}*...`
        }, { quoted: msg });

        // Busca mÃºltiplas pÃ¡ginas
        while (postLinks.length < 50 && page < maxPages) {
            const url = `https://rule34.xxx/index.php?page=post&s=list&tags=${encodeURIComponent(termo)}&pid=${page * 42}`;
            const res = await fetch(url, { headers });
            if (!res.ok) break;

            const html = await res.text();
            const $ = cheerio.load(html);

            $("span.thumb > a").each((_, el) => {
                const href = $(el).attr("href");
                if (href) postLinks.push(`https://rule34.xxx/${href}`);
            });

            page++;
        }

        // Remove duplicados
        postLinks = [...new Set(postLinks)];

        if (!postLinks.length) {
            return sock.sendMessage(from, {
                text: `âŒ Nenhuma imagem encontrada para *${termo}*`
            }, { quoted: msg, edit: carregando.key });
        }

        // Embaralha e limita
        postLinks = postLinks.sort(() => Math.random() - 0.5).slice(0, 15);

        // Busca imagens em paralelo
        let images = await Promise.all(
            postLinks.map(async (postLink) => {
                try {
                    const resImage = await fetch(postLink, { headers });
                    if (!resImage.ok) return null;

                    const htmlImage = await resImage.text();
                    const $$ = cheerio.load(htmlImage);

                    let img = $$("img#image").attr("src");
                    if (!img) return null;

                    return img.startsWith("http") ? img : "https:" + img;
                } catch {
                    return null;
                }
            })
        );

        images = images.filter(Boolean);

        if (!images.length) {
            return sock.sendMessage(from, {
                text: "âŒ NÃ£o foi possÃ­vel buscar as imagens."
            }, { quoted: msg, edit: carregando.key });
        }

        // Envia imagens com delay (anti-ban)
        for (const img of images) {
            await sock.sendMessage(from, {
                image: { url: img },
                mentions: [user]
            }, { quoted: msg });

            await new Promise(r => setTimeout(r, 350));
        }

        // ConfirmaÃ§Ã£o final
        await sock.sendMessage(from, {
            text: `âœ… ${images.length} imagens HD/4K enviadas com sucesso!`
        }, { quoted: msg, edit: carregando.key });

    } catch (err) {
        console.error("Erro hentaihd2:", err);
        await sock.sendMessage(from, {
            text: "âŒ Erro ao buscar hentai HD/4K. Tente novamente."
        }, { quoted: msg });
    }
    break;
}








case "0play":
case "0play3": {
    try {
        const q = args.join(" ");
        if (!q) return sock.sendMessage(from, { text: `âŒ Exemplo: ${config.prefix}play nome da mÃºsica` }, { quoted: msg });

        // Mensagem inicial da barra de carregamento
        let loadingMsg = await sock.sendMessage(from, { text: "â˜£ï¸ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });

        const atualizarBarra = async (percent, texto) => {
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);
            await sock.sendMessage(from, { text: `â˜£ï¸ ${barra} ${percent}% - ${texto}`, edit: loadingMsg.key });
        };

        // Etapas da barra
        await atualizarBarra(10, "Iniciando consulta...");
        await atualizarBarra(40, "Buscando mÃºsica...");
        await atualizarBarra(70, "Processando resultados...");

        // Pesquisa na API
        const res = await fetch(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`);
        if (!res.ok) return sock.sendMessage(from, { text: "âŒ Erro ao consultar a API de pesquisa." }, { quoted: msg });

        const data = await res.json();
        if (!data || !Array.isArray(data) || data.length === 0) return sock.sendMessage(from, { text: "âŒ Nenhum resultado encontrado." }, { quoted: msg });

        const musica = data[0];
        if (musica?.tempo?.length >= 7) return sock.sendMessage(from, { text: "âŒ MÃºsica muito longa (mais de 1 hora)." }, { quoted: msg });

        const titulo = musica?.titulo || "NÃ£o encontrado";
        const tempo = musica?.tempo || "NÃ£o informado";
        const postado = musica?.postado || "NÃ£o informado";
        const descricao = (musica?.desc || "NÃ£o informado").substring(0, 500) + "...";

        // Card musical
        const cardUrl = `https://zero-two-apis.com.br/api/musicard?nome=${encodeURIComponent(titulo)}&canal=${pushname}&foto=https://zero-two.info/uploads/images/file-1744800581218-175173952.jpeg&duracao=${tempo}&apikey=${API_KEY_ZEROTWO}`;

        const mensagem = `ğŸµ *MÃšSICA ENCONTRADA* ğŸµ

â˜£ï¸ UsuÃ¡rio: ${pushname}
â˜£ï¸ TÃ­tulo: ${titulo}
â˜£ï¸ DuraÃ§Ã£o: ${tempo}
â˜£ï¸ Postado: ${postado}
â˜£ï¸ DescriÃ§Ã£o: ${descricao}

â˜ªï¸ Bot: ${config.NomeDoBot}
â˜ªï¸ Pedido: @${msg.sender.split("@")[0]}`;

        // Finaliza barra
        await atualizarBarra(100, "ConcluÃ­do!");

        // Envia card musical
        await sock.sendMessage(from, {
            image: { url: cardUrl },
            caption: mensagem,
            mentions: [msg.sender]
        }, { quoted: msg });

        // Envia mÃºsica em Ã¡udio
        await sock.sendMessage(from, {
            audio: {
                url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`
            },
            mimetype: "audio/mpeg",
            fileName: `${titulo}.mp3`
        }, { quoted: msg });

    } catch (e) {
        console.error("Erro no comando /play:", e);
        await sock.sendMessage(from, { text: "âŒ Erro ao processar a mÃºsica. Tente novamente mais tarde." }, { quoted: msg });
    }
}
break;


case "yt":
case "yt-mp4":
case "YouTube-mp4":
case "youtube-mp4":
case "ytmp4": {
    try {
        const q = args.join(" ").trim();
        if (!q) {
            return sock.sendMessage(from, { 
                text: `âŒ Exemplo: ${config.prefix}ytmp4 https://www.youtube.com/watch?v=VIDEO_ID\nğŸ“Œ Suporta tambÃ©m Shorts do YouTube!` 
            }, { quoted: msg });
        }

        // Regex melhorada para aceitar quase todos links do YouTube
        if (!q.match(/^(https?:\/\/)?(www\.|m\.)?(youtube\.com|youtu\.be)\/(watch\?v=|shorts\/)?[^\s]+$/)) {
            return sock.sendMessage(from, { 
                text: "âŒ Link invÃ¡lido. Envie um link direto do YouTube ou Shorts." 
            }, { quoted: msg });
        }

        // Barra de progresso
        let loadingMsg;
        try {
            loadingMsg = await sock.sendMessage(from, { text: "â˜£ï¸ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });
        } catch (err) {
            console.warn("NÃ£o foi possÃ­vel criar barra de progresso:", err);
        }

        const atualizarBarra = async (percent, texto) => {
            if (!loadingMsg) return;
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);
            try {
                await sock.sendMessage(from, { text: `â˜£ï¸ ${barra} ${percent}% - ${texto}`, edit: loadingMsg.key });
            } catch (err) {}
        };

        await atualizarBarra(10, "Iniciando busca...");
        await atualizarBarra(40, "Consultando vÃ­deo...");
        await atualizarBarra(70, "Preparando download...");
        await atualizarBarra(90, "Quase pronto...");

        // API SpiderX
        const apiKey = "RT6FUqWnOUmIw7cs3lXX"; 
        const encodedURL = encodeURIComponent(q);
        const apiURL = `https://api.spiderx.com.br/api/downloads/yt-mp4?url=${encodedURL}&api_key=${apiKey}`;

        const res = await fetch(apiURL);
        if (!res.ok) {
            console.log(`Erro na API: ${res.status} - ${res.statusText}`);
            return sock.sendMessage(from, { text: `âŒ Erro ao consultar a API. Status: ${res.status}` }, { quoted: msg });
        }

        const data = await res.json();
        if (!data || !data.url) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "ğŸ” Nenhum vÃ­deo encontrado." }, { quoted: msg });
        }

        await atualizarBarra(100, "ConcluÃ­do!");

        // Nome de arquivo seguro
        const safeTitle = (data.title || "video").replace(/[^a-zA-Z0-9_\-]/g, "_");

        // Baixar vÃ­deo como buffer
        const videoRes = await fetch(data.url);
        const videoBuffer = Buffer.from(await videoRes.arrayBuffer());

        // Verificar tamanho
        const sizeMB = videoBuffer.length / 1024 / 1024;
        if (sizeMB > 15) {
            return sock.sendMessage(from, { 
                text: `âš ï¸ O vÃ­deo Ã© muito grande para enviar pelo WhatsApp (~${sizeMB.toFixed(2)}MB).\nğŸ”— VocÃª pode baixÃ¡-lo diretamente: ${data.url}` 
            }, { quoted: msg });
        }

        // Mensagem de informaÃ§Ãµes
        const msgInfo = `
à¼º â‹†ï½¡Ëšâ˜½Ëšï½¡â‹† *SPIDERX - DOWNLOAD YT* â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†à¼»
ğŸ¬ *TÃ­tulo:* ${data.title || "NÃ£o encontrado"}
ğŸ•’ *DuraÃ§Ã£o:* ${data.total_duration_in_seconds || "N/A"} segundos
ğŸ“º *Canal:* ${data.channel?.name || "NÃ£o encontrado"}
ğŸ”— [Canal](${data.channel?.url || "#"})

âš¡ *CompatÃ­vel com vÃ­deos e Shorts!*
à¼º â‹†ï½¡Ëšâ˜½Ëšï½¡â‹† *SPIDERX - DOWNLOAD YT* â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†à¼»
`;
        await sock.sendMessage(from, { text: msgInfo }, { quoted: msg });

        // Enviar vÃ­deo como buffer
        await sock.sendMessage(from, {
            video: videoBuffer,
            mimetype: "video/mp4",
            fileName: `${safeTitle}.mp4`
        }, { quoted: msg });

    } catch (e) {
        console.error("Erro interno:", e);
        await sock.sendMessage(from, { 
            text: "âŒ Ocorreu um erro ao baixar o vÃ­deo. Verifique o link e tente novamente." 
        }, { quoted: msg });
    }
}
break;







case "ytmp3":
case "yt-mp3":
case "youtube-mp3":
case "yt-audio": {
    try {
        const q = args.join(" ").trim();
        if (!q) {
            return sock.sendMessage(from, { 
                text: `âŒ Exemplo: ${config.prefix}ytmp3 https://www.youtube.com/watch?v=VIDEO_ID` 
            }, { quoted: msg });
        }

        // Verifica se o link Ã© do YouTube
        if (!q.match(/^(https?:\/\/)?(www\.|m\.)?(youtube\.com|youtu\.be)\/(watch\?v=|shorts\/)?[^\s]+$/)) {
            return sock.sendMessage(from, { 
                text: "âŒ Link invÃ¡lido. Envie um link direto do YouTube ou Shorts." 
            }, { quoted: msg });
        }

        // Barra de progresso
        let loadingMsg;
        try {
            loadingMsg = await sock.sendMessage(from, { text: "ğŸ§ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });
        } catch (err) {}

        const atualizarBarra = async (percent, texto) => {
            if (!loadingMsg) return;
            const total = 8;
            const filled = Math.round((percent / 100) * total);
            const bar = "â–°".repeat(filled) + "â–±".repeat(total - filled);
            try {
                await sock.sendMessage(from, { text: `ğŸ§ ${bar} ${percent}% - ${texto}`, edit: loadingMsg.key });
            } catch {}
        };

        await atualizarBarra(15, "Consultando vÃ­deo...");
        await atualizarBarra(50, "Convertendo para MP3...");
        await atualizarBarra(85, "Preparando envio...");

        // API SpiderX MP3
        const apiKey = "RT6FUqWnOUmIw7cs3lXX";
        const apiURL = `https://api.spiderx.com.br/api/downloads/yt-mp3?url=${encodeURIComponent(q)}&api_key=${apiKey}`;
        const res = await fetch(apiURL);
        if (!res.ok) throw new Error(`Erro API: ${res.status}`);

        const data = await res.json();
        if (!data?.url) throw new Error("URL invÃ¡lida retornada pela API");

        const audioRes = await fetch(data.url);
        const audioBuffer = Buffer.from(await audioRes.arrayBuffer());

        // Verifica tamanho mÃ¡ximo
        const sizeMB = audioBuffer.length / 1024 / 1024;
        if (sizeMB > 15) {
            return sock.sendMessage(from, { 
                text: `âš ï¸ O Ã¡udio Ã© muito grande (${sizeMB.toFixed(2)}MB).\nBaixe direto: ${data.url}` 
            }, { quoted: msg });
        }

        await atualizarBarra(100, "ConcluÃ­do!");

        // Envia apenas o Ã¡udio puro
        await sock.sendMessage(from, {
            audio: audioBuffer,
            mimetype: "audio/mpeg",
            fileName: `${(data.title || "audio").replace(/[^a-zA-Z0-9_\-]/g, "_")}.mp3`,
            ptt: false
        }, { quoted: msg });

    } catch (e) {
        console.error("Erro ao baixar Ã¡udio:", e);
        await sock.sendMessage(from, { 
            text: "âŒ Ocorreu um erro ao baixar o Ã¡udio. Tente novamente." 
        }, { quoted: msg });
    }
}
break;



case "tiktok": {
    const axios = require("axios");
    const fs = require("fs");
    const path = require("path");

    try {
        const q = args.join(" ").trim();
        if (!q)
            return sock.sendMessage(from, { 
                text: `âŒ Exemplo: ${config.prefix}tiktok https://vm.tiktok.com/EXEMPLO` 
            });

        // ğŸ”§ Converte vt.tiktok.com -> vm.tiktok.com automaticamente
        const tiktokURL = q.replace("vt.tiktok.com", "vm.tiktok.com");

        // ğŸŸ¢ Remove qualquer checagem de admin / dono / premium
        // Assim qualquer pessoa pode usar o comando livremente

        // âœ… Verifica se o link Ã© vÃ¡lido
        if (!tiktokURL.match(/^(https?:\/\/)?(www\.|vm\.)?(tiktok\.com)\/.+$/)) {
            return sock.sendMessage(from, { text: "âŒ Link invÃ¡lido. Envie um link direto do TikTok." });
        }

        await sock.sendMessage(from, { text: "â³ Baixando vÃ­deo, aguarde..." });

        const apiKey = "RT6FUqWnOUmIw7cs3lXX";
        const apiURL = `https://api.spiderx.com.br/api/downloads/tik-tok?url=${encodeURIComponent(tiktokURL)}&api_key=${apiKey}`;

        const res = await axios.get(apiURL);
        const data = res.data;

        if (!data || !data.download_link) {
            return sock.sendMessage(from, { text: "âŒ Nenhum vÃ­deo encontrado." });
        }

        const safeTitle = (data.title || "tiktok_video").replace(/[^a-zA-Z0-9_\-]/g, "_");
        const tempFile = path.join(__dirname, `${safeTitle}.mp4`);

        // ğŸ“¥ Baixa o vÃ­deo
        const videoRes = await axios.get(data.download_link, { responseType: "arraybuffer" });
        fs.writeFileSync(tempFile, Buffer.from(videoRes.data, "binary"));

        // ğŸ“¤ Envia o vÃ­deo
        await sock.sendMessage(from, {
            video: fs.readFileSync(tempFile),
            fileName: `${safeTitle}.mp4`,
            caption: `âœ… VÃ­deo baixado com sucesso!\nğŸ¥ ${data.title || "TikTok"}`
        });

        fs.unlinkSync(tempFile);

    } catch (e) {
        console.error("Erro no comando TikTok:", e);
        await sock.sendMessage(from, { text: "âŒ Erro ao baixar o vÃ­deo. Tente novamente mais tarde." });
    }
}
break;


case "p": 
case "play": {
    try {
        const q = args.join(" ").trim();
        if (!q) return sock.sendMessage(from, { 
            text: `âŒ Exemplo: ${config.prefix}play nome da mÃºsica ou link\nSerÃ¡ baixado apenas o Ã¡udio.` 
        }, { quoted: msg });

        // Barra de progresso
        let loadingMsg;
        try {
            loadingMsg = await sock.sendMessage(from, { text: "â˜£ï¸ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });
        } catch (err) {
            console.warn("NÃ£o foi possÃ­vel criar barra de progresso:", err);
        }

        const atualizarBarra = async (percent, texto) => {
            if (!loadingMsg) return;
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);
            try {
                await sock.sendMessage(from, { text: `â˜£ï¸ ${barra} ${percent}% - ${texto}`, edit: loadingMsg.key });
            } catch (err) {}
        };

        await atualizarBarra(10, "Iniciando busca...");
        await atualizarBarra(40, "Pesquisando Ã¡udio...");
        await atualizarBarra(70, "Preparando download...");
        await atualizarBarra(90, "Quase pronto...");

        // API SpiderX Play Audio
        const apiKey = "RT6FUqWnOUmIw7cs3lXX";
        const apiURL = `https://api.spiderx.com.br/api/downloads/play-audio?search=${encodeURIComponent(q)}&api_key=${apiKey}`;

        const res = await fetch(apiURL);
        if (!res.ok) return sock.sendMessage(from, { text: `âŒ Erro ao consultar a API. Status: ${res.status}` }, { quoted: msg });

        const data = await res.json();
        if (!data || !data.url) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "ğŸ” Nenhum Ã¡udio encontrado." }, { quoted: msg });
        }

        await atualizarBarra(100, "ConcluÃ­do!");

        // Nome de arquivo seguro
        const safeTitle = (data.title || "play").replace(/[^a-zA-Z0-9_\-]/g, "_");

        // Mensagem informativa
        const msgInfo = `
à¼º â‹†ï½¡Ëšâ˜½Ëšï½¡â‹† *SPIDERX - ÃUDIO* â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†à¼»
ğŸµ *TÃ­tulo:* ${data.title || "NÃ£o encontrado"}
â± *DuraÃ§Ã£o:* ${data.total_duration_in_seconds || "NÃ£o encontrado"} segundos
ğŸ¤ *Canal:* ${data.channel?.name || "NÃ£o encontrado"}
ğŸ”— [Canal](${data.channel?.url || "#"})

${NomeDoBot}
à¼º â‹†ï½¡Ëšâ˜½Ëšï½¡â‹† *SPIDERX - ÃUDIO* â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†à¼»
`;

        await sock.sendMessage(from, { text: msgInfo }, { quoted: msg });

        // Baixar Ã¡udio como buffer
        const audioRes = await fetch(data.url);
        const audioBuffer = Buffer.from(await audioRes.arrayBuffer());

        // Envio do Ã¡udio
        await sock.sendMessage(from, {
            audio: audioBuffer,
            mimetype: "audio/mpeg",
            fileName: `${safeTitle}.mp3`
        }, { quoted: msg });

    } catch (e) {
        console.log("Erro interno:", e);
        await sock.sendMessage(from, { text: "ğŸ” NÃ£o foi possÃ­vel encontrar o Ã¡udio. Tente ser mais especÃ­fico." }, { quoted: msg });
    }
}
break;





case "pv2":
case "playvideo2": {
    try {
        const q = args.join(" ").trim();
        if (!q) return sock.sendMessage(from, { 
            text: `âŒ Exemplo: ${config.prefix}playvideo2 nome da mÃºsica\nA mÃºsica serÃ¡ baixada em Ã¡udio ou vÃ­deo.` 
        }, { quoted: msg });

        // Barra de progresso
        let loadingMsg;
        try {
            loadingMsg = await sock.sendMessage(from, { text: "â˜£ï¸ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });
        } catch (err) {
            console.warn("NÃ£o foi possÃ­vel criar barra de progresso:", err);
        }

        const atualizarBarra = async (percent, texto) => {
            if (!loadingMsg) return;
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);
            try {
                await sock.sendMessage(from, { text: `â˜£ï¸ ${barra} ${percent}% - ${texto}`, edit: loadingMsg.key });
            } catch (err) {}
        };

        await atualizarBarra(10, "Iniciando busca...");
        await atualizarBarra(40, "Pesquisando vÃ­deo...");
        await atualizarBarra(70, "Preparando download...");
        await atualizarBarra(90, "Quase pronto...");

        // Busca dados no Bronxy
        const res = await fetch(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`);
        if (!res.ok) return sock.sendMessage(from, { text: "âŒ Erro ao consultar a API." }, { quoted: msg });

        const data = await res.json();
        if (!Array.isArray(data) || !data.length) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "ğŸ” Nenhum resultado encontrado." }, { quoted: msg });
        }

        const videoInfo = data[0];

        const tempoEmSegundos = (tempo) => {
            if (!tempo) return 0;
            const partes = tempo.split(":").map(Number);
            return partes.reverse().reduce((acc, val, i) => acc + val * Math.pow(60, i), 0);
        };

        if (tempoEmSegundos(videoInfo?.tempo || "0:0") > 7200) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "â± Este vÃ­deo Ã© muito longo (mais de 2 horas). Use outra busca." }, { quoted: msg });
        }

        let descricao = videoInfo?.desc || "NÃ£o encontrado";
        if (descricao.length > 300) descricao = descricao.slice(0, 300) + "...";

        const msgInfo = `
â˜£ï¸ *TÃ­tulo:* ${videoInfo?.titulo || "NÃ£o encontrado"}
â˜£ï¸ *DuraÃ§Ã£o:* ${videoInfo?.tempo || "NÃ£o encontrado"}
â˜£ï¸ *Postado:* ${videoInfo?.postado || "NÃ£o encontrado"}
â˜£ï¸ *DescriÃ§Ã£o:* ${descricao}
`;

        await atualizarBarra(100, "ConcluÃ­do!");
        await sock.sendMessage(from, {
            image: { url: videoInfo?.thumb || 'https://i.imgur.com/3q4W8K7.png' },
            caption: msgInfo
        }, { quoted: msg });

        const audioUrl = `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`;
        const videoUrl = `https://api.bronxyshost.com.br/api-bronxys/play_video?nome_url=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`;

        const safeTitle = (videoInfo?.titulo || "play").replace(/[^a-zA-Z0-9_\-]/g, "_");

        // Envio de Ã¡udio
        try {
            await sock.sendMessage(from, {
                audio: { url: audioUrl },
                mimetype: "audio/mpeg",
                fileName: `${safeTitle}.mp3`
            }, { quoted: msg });
        } catch (e) {
            console.log("Erro ao enviar Ã¡udio:", e);
            await sock.sendMessage(from, { text: `âš ï¸ NÃ£o foi possÃ­vel enviar o Ã¡udio. Link direto: ${audioUrl}` }, { quoted: msg });
        }

        // Envio de vÃ­deo
        try {
            const response = await fetch(videoUrl);
            const buffer = await response.arrayBuffer();
            const tamanhoMB = buffer.byteLength / 1024 / 1024;

            if (tamanhoMB > 90) {
                await sock.sendMessage(from, { text: `âš ï¸ O vÃ­deo Ã© muito grande para enviar (~${tamanhoMB.toFixed(2)} MB). Link direto: ${videoUrl}` }, { quoted: msg });
            } else {
                await sock.sendMessage(from, {
                    video: { url: videoUrl },
                    mimetype: "video/mp4",
                    fileName: `${safeTitle}.mp4`
                }, { quoted: msg });
            }
        } catch (e) {
            console.log("Erro ao enviar vÃ­deo:", e);
            await sock.sendMessage(from, { text: `âš ï¸ NÃ£o foi possÃ­vel enviar o vÃ­deo. Link direto: ${videoUrl}` }, { quoted: msg });
        }

    } catch (e) {
        console.log(e);
        await sock.sendMessage(from, { text: "ğŸ” NÃ£o foi possÃ­vel encontrar resultados. Tente ser mais especÃ­fico." }, { quoted: msg });
    }
}
break;

case "p2":
case "play2": {
    try {
        const q = args.join(" ");
        if (!q.trim()) return sock.sendMessage(from, { text: `âŒ Exemplo: ${config.prefix}play nome da mÃºsica\nA mÃºsica serÃ¡ baixada em Ã¡udio.` }, { quoted: msg });

        // Envia a mensagem inicial da barra de carregamento
        let loadingMsg = await sock.sendMessage(from, { text: "â˜£ï¸ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });

        const atualizarBarra = async (percent, texto) => {
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);

            // Edita a mensagem anterior para atualizar a barra
            await sock.sendMessage(from, { 
                text: `â˜£ï¸ ${barra} ${percent}% - ${texto}`, 
                edit: loadingMsg.key 
            });
        };

        // AtualizaÃ§Ãµes progressivas
        await atualizarBarra(10, "Iniciando busca...");
        await atualizarBarra(40, "Pesquisando mÃºsica...");
        await atualizarBarra(70, "Preparando download...");
        await atualizarBarra(90, "Quase pronto...");

        // Busca dados no Bronxy
        const res = await fetch(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`);
        if (!res.ok) return sock.sendMessage(from, { text: "âŒ Erro ao consultar a API." }, { quoted: msg });

        const data = await res.json();
        if (!Array.isArray(data) || !data.length) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "ğŸ” Nenhum resultado encontrado." }, { quoted: msg });
        }

        const videoInfo = data[0];

        const tempoEmSegundos = (tempo) => {
            if (!tempo) return 0;
            const partes = tempo.split(":").map(Number);
            return partes.reverse().reduce((acc, val, i) => acc + val * Math.pow(60, i), 0);
        };

        if (tempoEmSegundos(videoInfo?.tempo || "0:0") > 7200) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "â± Este vÃ­deo Ã© muito longo (mais de 2 horas). Use outra busca." }, { quoted: msg });
        }

        let descricao = videoInfo?.desc || "NÃ£o encontrado";
        if (descricao.length > 300) descricao = descricao.slice(0, 300) + "...";

        const msgInfo = `
 à¼º â‹†ï½¡Ëšâ˜½Ëšï½¡â‹† *YTB - ÃUDIO* â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†à¼»      
â˜£ï¸ *TÃ­tulo:* ${videoInfo?.titulo || "NÃ£o encontrado"}
â˜£ï¸ *DuraÃ§Ã£o:* ${videoInfo?.tempo || "NÃ£o encontrado"}
â˜£ï¸ *Postado:* ${videoInfo?.postado || "NÃ£o encontrado"}
â˜£ï¸ *DescriÃ§Ã£o:* ${descricao}

 ${NomeDoBot}
 
 à¼º â‹†ï½¡Ëšâ˜½Ëšï½¡â‹† *YTB - ÃUDIO* â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†à¼»
`;

        await atualizarBarra(100, "ConcluÃ­do!");
        await sock.sendMessage(from, {
            image: { url: videoInfo?.thumb || 'https://i.imgur.com/3q4W8K7.png' },
            caption: msgInfo
        }, { quoted: msg });

        const audioUrl = `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`;

        // Envio de Ã¡udio
        try {
            await sock.sendMessage(from, {
                audio: { url: audioUrl },
                mimetype: "audio/mpeg",
                fileName: `${videoInfo?.titulo || "play"}.mp3`
            }, { quoted: msg });
        } catch (e) {
            console.log("Erro ao enviar Ã¡udio:", e);
            await sock.sendMessage(from, { text: `âš ï¸ NÃ£o foi possÃ­vel enviar o Ã¡udio. Link direto: ${audioUrl}` }, { quoted: msg });
        }

    } catch (e) {
        console.log(e);
        await sock.sendMessage(from, { text: "ğŸ” NÃ£o foi possÃ­vel encontrar resultados. Tente ser mais especÃ­fico." }, { quoted: msg });
    }
}
break;





case "blackbox":
case "bb":
case "Blackbox":
case "BLACKBOX": {
    try {
        const q = args.join(" ").trim();
        if (!q) {
            return sock.sendMessage(from, {
                text: `âŒ Exemplo: ${config.prefix}blackbox O que Ã© obsolescÃªncia programada?`
            }, { quoted: msg });
        }

        // Mensagem de carregamento
        await sock.sendMessage(from, {
            text: "ğŸ¤– Consultando a IA Blackbox..."
        }, { quoted: msg });

        const apiKey = "Dragon250";
        const baseUrl = "https://tedzinho.com.br/api/ia/blackbox";

        let res, textResponse, data;

        // ğŸ”¹ Primeira tentativa: POST
        try {
            res = await fetch(`${baseUrl}?apikey=${apiKey}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ prompt: q })
            });

            textResponse = await res.text();
            try {
                data = JSON.parse(textResponse);
            } catch {
                data = { response: textResponse }; // Se nÃ£o for JSON, usa texto bruto
            }

            // Se HTML ou status ruim, fallback para GET
            if (!res.ok || textResponse.startsWith("<")) throw new Error("POST falhou");
        } catch (err) {
            console.log("âš ï¸ Falha no POST, tentando via GET...");
            const getUrl = `${baseUrl}?apikey=${apiKey}&prompt=${encodeURIComponent(q)}`;
            res = await fetch(getUrl);
            textResponse = await res.text();
            try {
                data = JSON.parse(textResponse);
            } catch {
                data = { response: textResponse }; // texto bruto
            }
        }

        // ğŸ” Extrai resposta
        const resposta = data.response || data.resposta || data.raw || "Sem resposta disponÃ­vel no momento.";

        // Envia resposta no WhatsApp
        await sock.sendMessage(from, {
            text: `ğŸ§  *Blackbox IA*:\n\n${resposta}`
        }, { quoted: msg });

    } catch (e) {
        console.log("Erro interno na case Blackbox:", e);
        await sock.sendMessage(from, {
            text: "âŒ Ocorreu um erro ao processar sua mensagem com a Blackbox."
        }, { quoted: msg });
    }
}
break;



case "gemini":
case "ia":
case "IA":
case "AI":
case "ai": {
    try {
        const q = args.join(" ").trim();
        if (!q) return sock.sendMessage(from, { text: `âŒ Exemplo: ${config.prefix}gemini OlÃ¡, como vocÃª estÃ¡?` }, { quoted: msg });

        // Mensagem de carregamento
        let loadingMsg = await sock.sendMessage(from, { text: "ğŸ¤– Processando sua mensagem..." }, { quoted: msg });

        const apiKey = "RT6FUqWnOUmIw7cs3lXX"; // Substitua pela sua chave

        const res = await fetch(`https://api.spiderx.com.br/api/ai/gemini?api_key=${apiKey}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: q })
        });

        if (!res.ok) {
            console.log(`Erro na API Gemini: ${res.status} - ${res.statusText}`);
            return sock.sendMessage(from, { text: `âŒ Erro ao consultar a API. Status: ${res.status}` }, { quoted: msg });
        }

        const data = await res.json();
        if (!data || !data.response) {
            return sock.sendMessage(from, { text: "ğŸ” Nenhuma resposta foi gerada pela IA." }, { quoted: msg });
        }

        // Envia a resposta da IA
        await sock.sendMessage(from, { text: `âœ¨ *IA*:\n\n${data.response}` }, { quoted: msg });

    } catch (e) {
        console.log("Erro interno na case Gemini:", e);
        await sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao processar sua mensagem com a Gemini." }, { quoted: msg });
    }
}
break;





case "play3": {
    try {
        const query = args.join(" ").trim();
        if (!query) return sock.sendMessage(from, {
            text: `âŒ Exemplo: ${config.prefix}playaudio casa do seu ze`
        }, { quoted: msg });

        const apiURL = `https://tedzinho.com.br/api/download/play_audio?apikey=Dragon250&nome_url=${encodeURIComponent(query)}`;
        const res = await fetch(apiURL);
        const data = await res.json();

        if (!data?.resultado?.dl_link) {
            return sock.sendMessage(from, { text: "âŒ Nenhum Ã¡udio encontrado." }, { quoted: msg });
        }

        const info = data.resultado;
        const msgInfo = `
ğŸ§ *TEDZINHO - ÃUDIO*
ğŸµ *TÃ­tulo:* ${info.title}
ğŸ“º *Canal:* ${info.channel}
ğŸ•’ *DuraÃ§Ã£o:* ${info.timestamp}
ğŸ‘ *VisualizaÃ§Ãµes:* ${info.viewsCount}
ğŸ“… *Postado:* ${info.uploadDate}
ğŸ”— *Ouvir:* ${info.externalUrls?.audio}
â¬‡ï¸ *Baixar:* ${info.dl_link}
`;

        await sock.sendMessage(from, { text: msgInfo }, { quoted: msg });

    } catch (err) {
        console.error("Erro na case playaudio:", err);
        await sock.sendMessage(from, { text: "âŒ Erro ao processar o Ã¡udio." }, { quoted: msg });
    }
}
break;





case "playvideo3": {
    try {
        const query = args.join(" ").trim();
        if (!query) return sock.sendMessage(from, {
            text: `âŒ Exemplo: ${config.prefix}playvideo casa do seu ze`
        }, { quoted: msg });

        const apiURL = `https://tedzinho.com.br/api/download/play_video?apikey=Dragon250&nome_url=${encodeURIComponent(query)}`;
        const res = await fetch(apiURL);
        const data = await res.json();

        if (!data?.resultado?.dl_link) {
            return sock.sendMessage(from, { text: "âŒ Nenhum vÃ­deo encontrado." }, { quoted: msg });
        }

        const info = data.resultado;
        const msgInfo = `
ğŸ¬ *TEDZINHO - VÃDEO*
ğŸµ *TÃ­tulo:* ${info.title}
ğŸ“º *Canal:* ${info.channel}
ğŸ•’ *DuraÃ§Ã£o:* ${info.timestamp}
ğŸ‘ *VisualizaÃ§Ãµes:* ${info.viewsCount}
ğŸ“… *Postado:* ${info.uploadDate}
ğŸ”— *Assistir:* ${info.externalUrls?.video}
â¬‡ï¸ *Baixar:* ${info.dl_link}
`;

        await sock.sendMessage(from, { text: msgInfo }, { quoted: msg });

    } catch (err) {
        console.error("Erro na case playvideo:", err);
        await sock.sendMessage(from, { text: "âŒ Erro ao processar o vÃ­deo." }, { quoted: msg });
    }
}
break;



case "pv": 
case "playvideo": {
    try {
        const q = args.join(" ").trim();
        if (!q) return sock.sendMessage(from, { 
            text: `âŒ Exemplo: ${config.prefix}playvideo MC Kevinho\nSerÃ¡ baixado apenas o vÃ­deo.` 
        }, { quoted: msg });

        // Barra de progresso
        let loadingMsg;
        try {
            loadingMsg = await sock.sendMessage(from, { text: "â˜£ï¸ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });
        } catch (err) {
            console.warn("NÃ£o foi possÃ­vel criar barra de progresso:", err);
        }

        const atualizarBarra = async (percent, texto) => {
            if (!loadingMsg) return;
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);
            try {
                await sock.sendMessage(from, { text: `â˜£ï¸ ${barra} ${percent}% - ${texto}`, edit: loadingMsg.key });
            } catch (err) {}
        };

        await atualizarBarra(10, "Iniciando busca...");
        await atualizarBarra(40, "Consultando vÃ­deo...");
        await atualizarBarra(70, "Preparando download...");
        await atualizarBarra(90, "Quase pronto...");

        // API SpiderX play-video
        const apiKey = "RT6FUqWnOUmIw7cs3lXX";
        const apiURL = `https://api.spiderx.com.br/api/downloads/play-video?search=${encodeURIComponent(q)}&api_key=${apiKey}`;

        const res = await fetch(apiURL);
        if (!res.ok) {
            console.log(`Erro na API play-video: ${res.status} - ${res.statusText}`);
            return sock.sendMessage(from, { text: `âŒ Erro ao consultar a API. Status: ${res.status}` }, { quoted: msg });
        }

        const data = await res.json();
        if (!data || !data.url) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "ğŸ” Nenhum vÃ­deo encontrado." }, { quoted: msg });
        }

        await atualizarBarra(100, "ConcluÃ­do!");

        // Sanitizar nome do arquivo
        const safeTitle = (data.title || "video").replace(/[^a-zA-Z0-9_\-]/g, "_");

        // Mensagem informativa
        const msgInfo = `
ğŸ¬ *SPIDERX - VÃDEO*
ğŸµ *TÃ­tulo:* ${data.title || "NÃ£o encontrado"}
â± *DuraÃ§Ã£o:* ${data.total_duration_in_seconds || "Desconhecida"} segundos
ğŸ¤ *Canal:* ${data.channel?.name || "NÃ£o encontrado"}
ğŸ”— [Canal](${data.channel?.url || "#"})

${NomeDoBot}
`;

        // Baixar vÃ­deo como buffer
        const videoRes = await fetch(data.url);
        const videoBuffer = Buffer.from(await videoRes.arrayBuffer());

        // Verificar tamanho do vÃ­deo
        const sizeMB = videoBuffer.length / 1024 / 1024;
        if (sizeMB > 15) {
            return sock.sendMessage(from, { 
                text: `âš ï¸ O vÃ­deo Ã© muito grande para enviar pelo WhatsApp (~${sizeMB.toFixed(2)}MB).\nğŸ”— VocÃª pode baixÃ¡-lo diretamente: ${data.url}` 
            }, { quoted: msg });
        }

        // Envio do vÃ­deo como buffer
        await sock.sendMessage(from, {
            video: videoBuffer,
            mimetype: "video/mp4",
            fileName: `${safeTitle}.mp4`,
            caption: msgInfo
        }, { quoted: msg });

    } catch (e) {
        console.log("Erro interno na case playvideo:", e);
        await sock.sendMessage(from, { text: "âŒ NÃ£o foi possÃ­vel baixar o vÃ­deo. Tente ser mais especÃ­fico." }, { quoted: msg });
    }
}
break;

case "flux": {
    try {
        const q = args.join(" ").trim();
        if (!q) return sock.sendMessage(from, { text: `âŒ Exemplo: ${config.prefix}flux Um cachorro azul brincando no parque` }, { quoted: msg });

        // Mensagem inicial da barra de carregamento
        let loadingMsg = await sock.sendMessage(from, { text: "ğŸ¨ â–±â–±â–±â–±â–±â–±â–±â–± 0% - Iniciando..." }, { quoted: msg });

        const atualizarBarra = async (percent, texto) => {
            const total = 8;
            const preenchido = Math.round((percent / 100) * total);
            const barra = "â–°".repeat(preenchido) + "â–±".repeat(total - preenchido);
            await sock.sendMessage(from, { text: `ğŸ¨ ${barra} ${percent}% - ${texto}`, edit: loadingMsg.key });
        };

        await atualizarBarra(10, "Recebendo requisiÃ§Ã£o...");
        await atualizarBarra(40, "Gerando imagem...");
        await atualizarBarra(70, "Processando resultado...");
        await atualizarBarra(90, "Quase pronto...");

        const apiKey = "RT6FUqWnOUmIw7cs3lXX"; // Substitua pela sua chave
        const apiURL = `https://api.spiderx.com.br/api/ai/flux?text=${encodeURIComponent(q)}&api_key=${apiKey}`;

        const res = await fetch(apiURL);
        if (!res.ok) {
            console.log(`Erro na API Flux: ${res.status} - ${res.statusText}`);
            return sock.sendMessage(from, { text: `âŒ Erro ao consultar a API. Status: ${res.status}` }, { quoted: msg });
        }

        const data = await res.json();
        if (!data || !data.image) {
            await atualizarBarra(100, "ConcluÃ­do");
            return sock.sendMessage(from, { text: "ğŸ” Nenhuma imagem foi gerada." }, { quoted: msg });
        }

        await atualizarBarra(100, "ConcluÃ­do!");

        // Envia a imagem gerada
        await sock.sendMessage(from, {
            image: { url: data.image },
            caption: `ğŸ–¼ Flux:\n${q}`
        }, { quoted: msg });

    } catch (e) {
        console.log("Erro interno na case Flux:", e);
        await sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao gerar a imagem." }, { quoted: msg });
    }
}
break;



case 'gerarnick': {
    try {
        const q = args.join(" ");
        if (!q.trim()) {
            return sock.sendMessage(from, { text: `âŒ Escreva um nome para eu enviar ele com letras modificadas.\nExemplo: ${config.prefix + command} bronxys` }, { quoted: msg });
        }

        // Mensagem de carregamento
        const carregando = await sock.sendMessage(from, { text: "â˜£ï¸ AGUARDE, GERANDO LISTA DE NICKS..." }, { quoted: msg });

        // Consulta Ã  API
        const ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/gerar_nick?nick=${encodeURIComponent(q)}&apikey=${API_KEY_BRONXYS}`);

        let AB = `âœ¨ Lista com base no nick informado:\n\n`;
        for (const i of ABC) {
            AB += `${i}\n\n`;
        }

        // Envia resultado final e edita a mensagem de carregamento
        await sock.sendMessage(from, { text: AB.trim() }, { quoted: msg, edit: carregando.key });

        // Log do comando
        logActivity('COMMAND_EXECUTED', {
            command,
            isGroup,
            groupName: isGroup ? perms.groupName : null,
            groupId: from
        });

    } catch (e) {
        console.error(e);
        return sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao gerar os nicks." }, { quoted: msg });
    }
    break;
}



case 'es':
case 's':
case 'sticker':
case 'figurinha': {
  try {
    const { downloadContentFromMessage } = require('@adiwajshing/baileys');
    const fs = require('fs');
    const path = require('path');
    const { exec } = require('child_process');

    let media = msg.message.imageMessage || msg.message.videoMessage;
    const quoted = msg.message.extendedTextMessage?.contextInfo?.quotedMessage;
    if (!media && quoted) media = quoted.imageMessage || quoted.videoMessage;
    if (!media) return sock.sendMessage(from, { text: 'âŒ Envie ou marque uma imagem, vÃ­deo ou GIF!' }, { quoted: msg });

    const mediaType = media.mimetype.split('/')[0];
    const extension = media.mimetype.split('/')[1];

    // ğŸ“ Cria pasta temporÃ¡ria
    const tempDir = path.join(__dirname, 'temp_stickers');
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });

    const tempFile = path.join(tempDir, `input.${extension}`);
    const outputFile = path.join(tempDir, `output.webp`);

    // â¬‡ï¸ Baixa mÃ­dia
    let stream = await downloadContentFromMessage(media, mediaType);
    let buffer = Buffer.from([]);
    for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);
    fs.writeFileSync(tempFile, buffer);

    // âš™ï¸ Verifica se Ã© vÃ­deo, imagem ou gif animado
    const isVideo = media.mimetype.includes('video');
    const isGif = media.mimetype.includes('gif');

    // ğŸï¸ ConversÃ£o (ffmpeg)
    const ffmpegCmd = isVideo || isGif
      ? `ffmpeg -i "${tempFile}" -vf "scale=512:512:force_original_aspect_ratio=decrease,fps=15,pad=512:512:-1:-1:color=white" -vcodec libwebp -loop 0 -preset default -an -vsync 0 -t 10 -y "${outputFile}"`
      : `ffmpeg -i "${tempFile}" -vf "scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:-1:-1:color=white" -vcodec libwebp -lossless 1 -qscale 1 -preset default -y "${outputFile}"`;

    await new Promise((resolve, reject) => {
      exec(ffmpegCmd, (err) => (err ? reject(err) : resolve()));
    });

    // ğŸ“¤ Envia figurinha
    const stickerBuffer = fs.readFileSync(outputFile);
    await sock.sendMessage(from, { sticker: stickerBuffer }, { quoted: msg });

    // ğŸ§¹ Limpa arquivos temporÃ¡rios
    fs.unlinkSync(tempFile);
    fs.unlinkSync(outputFile);

  } catch (err) {
    console.error('Erro ao criar figurinha:', err);
    await sock.sendMessage(from, { text: 'âŒ Erro ao criar figurinha. Envie uma imagem, GIF ou vÃ­deo curto (â‰¤10s).' }, { quoted: msg });
  }
  break;
}





case 'togif':
case 'toimg':
case 'converter':
case 'webp2gif':
case 'webp2img': {
  try {
    const { downloadContentFromMessage } = require('@adiwajshing/baileys');
    const fs = require('fs');
    const path = require('path');
    const { exec } = require('child_process');

    let media = msg.message.stickerMessage;
    const quoted = msg.message.extendedTextMessage?.contextInfo?.quotedMessage;
    if (!media && quoted) media = quoted.stickerMessage;
    if (!media) return sock.sendMessage(from, { text: 'âŒ Envie ou marque uma figurinha para converter!' }, { quoted: msg });

    // ğŸ“ Pasta temporÃ¡ria
    const tempDir = path.join(__dirname, 'temp_convert');
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });

    const tempFile = path.join(tempDir, 'input.webp');
    const outputStatic = path.join(tempDir, 'output.png');
    const outputAnimated = path.join(tempDir, 'output.gif');

    // â¬‡ï¸ Baixa a figurinha
    let stream = await downloadContentFromMessage(media, 'sticker');
    let buffer = Buffer.from([]);
    for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);
    fs.writeFileSync(tempFile, buffer);

    // âš™ï¸ Detecta se Ã© figurinha animada
    const isAnimated = media.isAnimated || buffer.includes(Buffer.from('ANMF')); // ANMF = chunk de animaÃ§Ã£o WebP

    // ğŸï¸ Comando ffmpeg adequado
    const ffmpegCmd = isAnimated
      ? `ffmpeg -i "${tempFile}" -movflags faststart -pix_fmt rgb24 -loop 0 -f gif -y "${outputAnimated}"`
      : `ffmpeg -i "${tempFile}" -y "${outputStatic}"`;

    await new Promise((resolve, reject) => {
      exec(ffmpegCmd, (err) => (err ? reject(err) : resolve()));
    });

    // ğŸ“¤ Envia o resultado
    if (isAnimated) {
      const gifBuffer = fs.readFileSync(outputAnimated);
      await sock.sendMessage(from, { video: gifBuffer, gifPlayback: true, caption: 'ğŸ¬ Figurinha convertida em GIF!' }, { quoted: msg });
      fs.unlinkSync(outputAnimated);
    } else {
      const imgBuffer = fs.readFileSync(outputStatic);
      await sock.sendMessage(from, { image: imgBuffer, caption: 'ğŸ–¼ï¸ Figurinha convertida em imagem!' }, { quoted: msg });
      fs.unlinkSync(outputStatic);
    }

    // ğŸ§¹ Limpeza
    fs.unlinkSync(tempFile);

  } catch (err) {
    console.error('Erro ao converter figurinha:', err);
    await sock.sendMessage(from, { text: 'âŒ Erro ao converter a figurinha. Tente novamente!' }, { quoted: msg });
  }
  break;
}





case "pin":
case "pinterest": {
    const q = args.join(" ");
    if (!q) {
        return sock.sendMessage(from, { 
            text: `âŒ Digite o nome da imagem que deseja buscar\nExemplo: ${config.prefix}pinterest Goku`
        }, { quoted: msg });
    }

    const senderId = msg.key.participant || msg.key.remoteJid;
    await sock.sendMessage(from, { 
        text: `â³ ${new Date().toLocaleTimeString("pt-BR")}, @${senderId.split('@')[0]}.\n*Estou buscando imagens sobre "${q}"...*`,
        contextInfo: { mentionedJid: [senderId] }
    });

    try {
        const { data } = await axios.get(`${site}/api/pesquisa/pinterest?query=${encodeURIComponent(q)}&apikey=${API_KEY_SHADOW}`);
        
        if (!data || !data.resultado || data.resultado.length === 0) {
            return sock.sendMessage(from, { 
                text: `âš ï¸ Nenhuma imagem encontrada para: ${q}` 
            }, { quoted: msg });
        }

        // Pega atÃ© 3 imagens
        const imagens = data.resultado.slice(0, 3);

        for (const img of imagens) {
            try {
                const imageBuffer = await axios.get(img.image, { responseType: 'arraybuffer' });
                await sock.sendMessage(from, { 
                    image: Buffer.from(imageBuffer.data),
                    caption: `_*Pesquisa Pinterest:*_\nâ•°â”ˆâ¤ _*${q.toUpperCase()}*_\nğŸ•’ ${new Date().toLocaleTimeString("pt-BR")}`
                }, { quoted: msg });
            } catch (errImg) {
                console.error(`Erro ao enviar imagem: ${img.image}`, errImg);
            }
        }

    } catch (e) {
        console.error("Erro ao buscar imagens do Pinterest:", e);
        await sock.sendMessage(from, { 
            text: "âŒ Erro ao buscar imagens do Pinterest." 
        }, { quoted: msg });
    }
}
break;




case "pin2":
case "pinterest2": {
    const q = args.join(" ");
    if (!q) {
        return sock.sendMessage(from, { 
            text: `âŒ Digite o nome da imagem que deseja buscar\nExemplo: ${config.prefix}pinterest2 Goku`
        }, { quoted: msg });
    }

    const senderId = msg.key.participant || msg.key.remoteJid;

    await sock.sendMessage(from, { 
        text: `â³ ${new Date().toLocaleTimeString("pt-BR")}, @${senderId.split('@')[0]}.\n*Estou buscando imagens sobre "${q}"...*`,
        contextInfo: { mentionedJid: [senderId] }
    });

    try {
        const url = `https://tedzinho.com.br/api/pesquisa/pinterest?apikey=Dragon250&query=${encodeURIComponent(q)}`;

        const { data } = await axios.get(url);
        
        if (!data || !data.resultado || data.resultado.length === 0) {
            return sock.sendMessage(from, { 
                text: `âš ï¸ Nenhuma imagem encontrada para: ${q}` 
            }, { quoted: msg });
        }

        // â–“â–“â–“ EMBARALHAMENTO INTELIGENTE (SEM REPETIÃ‡ÃƒO) â–“â–“â–“
        let conjunto = data.resultado;

        // remove elementos duplicados pelo link real da imagem
        conjunto = conjunto.filter((item, index, self) =>
            index === self.findIndex(t => t.image === item.image)
        );

        // embaralha a lista sempre de forma diferente
        conjunto = conjunto
            .map(a => ({ sort: Math.random(), value: a }))
            .sort((a, b) => a.sort - b.sort)
            .map(a => a.value);

        // pega as 3 primeiras (todas Ãºnicas)
        const imagens = conjunto.slice(0, 3);

        // enviar as imagens
        for (const img of imagens) {
            try {
                const imageBuffer = await axios.get(img.image, {
                    responseType: 'arraybuffer'
                });

                await sock.sendMessage(
                    from,
                    { 
                        image: Buffer.from(imageBuffer.data),
                        caption: `_*Pesquisa Pinterest:*_\nâ•°â”ˆâ¤ _*${q.toUpperCase()}*_\nğŸ•’ ${new Date().toLocaleTimeString("pt-BR")}`
                    },
                    { quoted: msg }
                );

            } catch (errImg) {
                console.error(`Erro ao enviar imagem: ${img.image}`, errImg);
            }
        }

    } catch (e) {
        console.error("Erro ao buscar imagens do Pinterest:", e);
        await sock.sendMessage(from, { 
            text: "âŒ Erro ao buscar imagens do Pinterest." 
        }, { quoted: msg });
    }
}
break;




// Inicializa memÃ³ria global se nÃ£o existir
if (!global.wallpapersEnviados) {
    global.wallpapersEnviados = new Set();
    // Limpeza automÃ¡tica a cada 1 hora
    setInterval(() => {
        console.log("ğŸ—‘ï¸ Limpando memÃ³ria de wallpapers enviados...");
        global.wallpapersEnviados.clear();
    }, 1000 * 60 * 60);
}

case "wallpaper":
case "wp": {
    const q = args.join(" ");
    if (!q) {
        return sock.sendMessage(from, { 
            text: `âŒ Digite o nome do wallpaper.\nExemplo: ${config.prefix}wallpaper Naruto`
        }, { quoted: msg });
    }

    const senderId = msg.key.participant || msg.key.remoteJid;
    await sock.sendMessage(from, { 
        text: `ğŸ–¼ï¸ @${senderId.split('@')[0]}, buscando wallpapers 2K / Full HD sobre "${q}"...`,
        contextInfo: { mentionedJid: [senderId] }
    });

    try {
        const { data } = await axios.get(`https://tedzinho.com.br/api/pesquisa/wallpaper?apikey=Dragon250&query=${encodeURIComponent(q)}`);

        if (!data?.resultado?.length) {
            return sock.sendMessage(from, { text: `âš ï¸ Nenhum wallpaper encontrado para: ${q}` }, { quoted: msg });
        }

        const validas = data.resultado.map(item => {
            let url = item.imageURL?.replace("https://www.besthdwallpaper.comhttps://", "https://");

            if (Array.isArray(item.downloadLinks) && item.downloadLinks.length > 0) {
                const melhores = item.downloadLinks.filter(l => /(4k|3840x|2560x|1920x|1080)/i.test(l));
                if (melhores.length) url = melhores[0];
                else url = item.downloadLinks[item.downloadLinks.length - 1];
            }

            return {
                titulo: item.title || "Wallpaper",
                link: url,
                pagina: item.pageLink
            };
        }).filter(w => w.link && global.wallpapersEnviados?.has ? !global.wallpapersEnviados.has(w.link) : true);

        if (!validas.length) {
            return sock.sendMessage(from, { text: "âš ï¸ Nenhum wallpaper novo em alta qualidade encontrado." }, { quoted: msg });
        }

        // Embaralha resultados e seleciona atÃ© 3
        validas.sort(() => Math.random() - 0.5);
        const selecionados = validas.slice(0, 3);

        for (const w of selecionados) {
            try {
                const img = await axios.get(w.link, { responseType: "arraybuffer" });
                if (!img?.data) continue;

                await sock.sendMessage(from, { 
                    image: Buffer.from(img.data),
                    caption: `ğŸ–¼ï¸ *${w.titulo}*\nğŸ“¥ [Baixar em alta qualidade](${w.link})\nğŸ”— ${w.pagina}`
                }, { quoted: msg });

                if (global.wallpapersEnviados) global.wallpapersEnviados.add(w.link);
                await new Promise(r => setTimeout(r, 2000));
            } catch (err) {
                console.error("Erro ao enviar wallpaper:", err.message);
            }
        }

        await sock.sendMessage(from, { react: { text: "âœ…", key: msg.key } });

    } catch (err) {
        console.error("Erro ao buscar wallpapers:", err.message);
        await sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao buscar wallpapers." }, { quoted: msg });
    }
}
break;





// HistÃ³rico global de vÃ­deos enviados
// Chave: videoUrl, Valor: timestamp de envio
const globalSentVideos = new Map();

// Tempo mÃ­nimo para repetir o mesmo vÃ­deo (em ms)
const VIDEO_REPEAT_COOLDOWN = 24 * 60 * 60 * 1000; // 24 horas, ajuste conforme desejar

case "xvÃ­deos": 
case "xvideos": {
    const q = args.join(" ").trim();
    if (!q) {
        return sock.sendMessage(from, {
            text: `âŒ Digite o termo de busca.\nExemplo: ${config.prefix}adultsearch exemplo`
        }, { quoted: msg });
    }

    const bannedTerms = [
        "ninfet", "ninfeta", "teen", "minor", "child", "menor",
        "crianÃ§a", "adolescen", "preteen", "underage", "12", "13", "14", "15"
    ];
    const lowerQ = q.toLowerCase();
    for (const t of bannedTerms) if (lowerQ.includes(t)) {
        return sock.sendMessage(from, {
            text: `âŒ Busca bloqueada: o termo usado Ã© proibido.`
        }, { quoted: msg });
    }

    const senderId = msg.key.participant || msg.key.remoteJid;
    await sock.sendMessage(from, {
        text: `ğŸ” @${senderId.split('@')[0]}, pesquisando "${q}"...`,
        contextInfo: { mentionedJid: [senderId] }
    });

    try {
        const API_BASE_URL = "https://tedzinho.com.br/api/porn/xvideossearch";
        const API_KEY = "Dragon250";
        const url = `${API_BASE_URL}?apikey=${encodeURIComponent(API_KEY)}&query=${encodeURIComponent(q)}`;

        const { data } = await axios.get(url, { timeout: 10000 });
        const resultados = data?.resultado || data?.results || data?.items || [];

        if (!Array.isArray(resultados) || resultados.length === 0) {
            return sock.sendMessage(from, { text: `âš ï¸ Nenhum resultado encontrado para: ${q}` }, { quoted: msg });
        }

        const mapped = resultados.map(item => ({
            title: item.title || item.name || item.video_title || "VÃ­deo",
            page: item.pageLink || item.link || item.url || "",
            thumb: item.thumbnailURL || item.thumb || item.image || null,
            videoUrl: item.video_url || item.file || item.src || null
        })).filter(x => x.page || x.videoUrl);

        if (!mapped.length) {
            return sock.sendMessage(from, { text: `âš ï¸ Resultados encontrados, mas sem links vÃ¡lidos.` }, { quoted: msg });
        }

        // Filtra vÃ­deos que nÃ£o foram enviados recentemente
        const agora = Date.now();
        const disponiveis = mapped.filter(v => {
            if (!v.videoUrl) return true;
            const lastSent = globalSentVideos.get(v.videoUrl) || 0;
            return (agora - lastSent) > VIDEO_REPEAT_COOLDOWN;
        });

        if (!disponiveis.length) {
            return sock.sendMessage(from, { text: `âš ï¸ Todos os vÃ­deos jÃ¡ foram enviados recentemente.` }, { quoted: msg });
        }

        // Seleciona atÃ© 3 vÃ­deos aleatoriamente
        const selecionados = [];
        const copia = [...disponiveis];
        while (selecionados.length < 3 && copia.length > 0) {
            const idx = Math.floor(Math.random() * copia.length);
            selecionados.push(copia[idx]);
            copia.splice(idx, 1);
        }

        for (const r of selecionados) {
            try {
                if (r.thumb) {
                    await sock.sendMessage(from, {
                        image: { url: r.thumb },
                        caption: `ğŸ¥ *${r.title}*\nğŸ”— ${r.page}\n${r.videoUrl ? `â–¶ï¸ Link direto: ${r.videoUrl}` : ""}`
                    }, { quoted: msg });
                } else if (r.videoUrl) {
                    await sock.sendMessage(from, {
                        text: `ğŸ¥ *${r.title}*\nğŸ”— ${r.page}\nâ–¶ï¸ Link direto: ${r.videoUrl}`
                    }, { quoted: msg });
                } else {
                    await sock.sendMessage(from, { text: `ğŸ¥ *${r.title}*\nğŸ”— ${r.page}` }, { quoted: msg });
                }

                // Adiciona ao histÃ³rico global
                if (r.videoUrl) globalSentVideos.set(r.videoUrl, agora);

                await new Promise(res => setTimeout(res, 1200));
            } catch (err) {
                console.error("Erro ao enviar item:", err?.message || err);
            }
        }

        // Limpa globalSentVideos para remover links antigos
        for (const [url, ts] of globalSentVideos.entries()) {
            if (agora - ts > VIDEO_REPEAT_COOLDOWN) globalSentVideos.delete(url);
        }

        await sock.sendMessage(from, { react: { text: "âœ…", key: msg.key } });

    } catch (err) {
        console.error("Erro na case adultsearch:", err?.message || err);
        await sock.sendMessage(from, {
            text: "âœ…"
        }, { quoted: msg });
    }
}
break;







case "xnxx": {
    const q = args.join(" ").trim();
    if (!q) {
        return sock.sendMessage(from, {
            text: `âŒ Digite o termo de busca.\nExemplo: ${config.prefix}xnxx exemplo`
        }, { quoted: msg });
    }

    const bannedTerms = [
        "ninfet", "ninfeta", "teen", "minor", "child", "menor",
        "crianÃ§a", "adolescen", "preteen", "underage", "12", "13", "14", "15"
    ];
    const lowerQ = q.toLowerCase();
    for (const t of bannedTerms) if (lowerQ.includes(t)) {
        return sock.sendMessage(from, {
            text: `âŒ Busca bloqueada: o termo usado Ã© proibido.`
        }, { quoted: msg });
    }

    const senderId = msg.key.participant || msg.key.remoteJid;
    await sock.sendMessage(from, {
        text: `ğŸ” @${senderId.split('@')[0]}, pesquisando "${q}"...`,
        contextInfo: { mentionedJid: [senderId] }
    });

    try {
        const API_BASE_URL = "https://tedzinho.com.br/api/porn/xnxxsearch";
        const API_KEY = "Dragon250";
        const url = `${API_BASE_URL}?apikey=${encodeURIComponent(API_KEY)}&query=${encodeURIComponent(q)}`;

        const { data } = await axios.get(url, { timeout: 10000 });
        const resultados = data?.resultado || data?.results || data?.items || [];

        if (!Array.isArray(resultados) || resultados.length === 0) {
            return sock.sendMessage(from, { text: `âš ï¸ Nenhum resultado encontrado para: ${q}` }, { quoted: msg });
        }

        const mapped = resultados.map(item => ({
            title: item.title || item.name || item.video_title || "VÃ­deo",
            page: item.pageLink || item.link || item.url || "",
            thumb: item.thumbnailURL || item.thumb || item.image || null,
            videoUrl: item.video_url || item.file || item.src || null
        })).filter(x => x.page || x.videoUrl);

        if (!mapped.length) {
            return sock.sendMessage(from, { text: `âš ï¸ Resultados encontrados, mas sem links vÃ¡lidos.` }, { quoted: msg });
        }

        // Filtra vÃ­deos que nÃ£o foram enviados recentemente
        const agora = Date.now();
        const disponiveis = mapped.filter(v => {
            if (!v.videoUrl) return true;
            const lastSent = globalSentVideos.get(v.videoUrl) || 0;
            return (agora - lastSent) > VIDEO_REPEAT_COOLDOWN;
        });

        if (!disponiveis.length) {
            return sock.sendMessage(from, { text: `âš ï¸ Todos os vÃ­deos jÃ¡ foram enviados recentemente.` }, { quoted: msg });
        }

        // Seleciona atÃ© 3 vÃ­deos aleatoriamente
        const selecionados = [];
        const copia = [...disponiveis];
        while (selecionados.length < 3 && copia.length > 0) {
            const idx = Math.floor(Math.random() * copia.length);
            selecionados.push(copia[idx]);
            copia.splice(idx, 1);
        }

        for (const r of selecionados) {
            try {
                if (r.thumb) {
                    await sock.sendMessage(from, {
                        image: { url: r.thumb },
                        caption: `ğŸ¥ *${r.title}*\nğŸ”— ${r.page}\n${r.videoUrl ? `â–¶ï¸ Link direto: ${r.videoUrl}` : ""}`
                    }, { quoted: msg });
                } else if (r.videoUrl) {
                    await sock.sendMessage(from, {
                        text: `ğŸ¥ *${r.title}*\nğŸ”— ${r.page}\nâ–¶ï¸ Link direto: ${r.videoUrl}`
                    }, { quoted: msg });
                } else {
                    await sock.sendMessage(from, { text: `ğŸ¥ *${r.title}*\nğŸ”— ${r.page}` }, { quoted: msg });
                }

                // Adiciona ao histÃ³rico global
                if (r.videoUrl) globalSentVideos.set(r.videoUrl, agora);

                await new Promise(res => setTimeout(res, 1200));
            } catch (err) {
                console.error("Erro ao enviar item:", err?.message || err);
            }
        }

        // Limpa globalSentVideos para remover links antigos
        for (const [url, ts] of globalSentVideos.entries()) {
            if (agora - ts > VIDEO_REPEAT_COOLDOWN) globalSentVideos.delete(url);
        }

        await sock.sendMessage(from, { react: { text: "âœ…", key: msg.key } });

    } catch (err) {
        console.error("Erro na case xnxx:", err?.message || err);
        await sock.sendMessage(from, {
            text: "âœ…"
        }, { quoted: msg });
    }
}
break;



case "pinterestmp4":
case "pinmp4": {
    try {
        const q = args[0];
        const sender = msg.key.participant || msg.key.remoteJid;
        const pushname = msg.pushName || sender.split('@')[0];

        // FunÃ§Ã£o auxiliar: baixa e retorna buffer
        const getBuffer = async (url) => {
            const res = await axios.get(url, { responseType: 'arraybuffer' });
            return Buffer.from(res.data);
        };

        if (!q) {
            return sock.sendMessage(from, { 
                text: `âŒ Envie o link do Pinterest.\nExemplo: ${config.prefix + command} https://pin.it/4JWC02Bye`
            }, { quoted: msg });
        }

        // Mensagem de carregamento
        await sock.sendMessage(from, { 
            text: `â³ Baixando vÃ­deo do Pinterest...\nğŸ–‡ï¸ Link: ${q}`
        }, { quoted: msg });

        // FunÃ§Ã£o com tentativas e timeout
        const axiosWithRetry = async (url, attempts = 3, delayMs = 1000) => {
            for (let i = 0; i < attempts; i++) {
                try {
                    return await axios.get(url, { timeout: 15000 });
                } catch (err) {
                    const isLast = i === attempts - 1;
                    const status = err?.response?.status;
                    if (status && status >= 400 && status < 500) throw err;
                    if (isLast) throw err;
                    await new Promise(res => setTimeout(res, delayMs * Math.pow(2, i)));
                }
            }
        };

        const apiUrl = `${site}/api/download/pinterestmp4?url=${encodeURIComponent(q)}&apikey=${API_KEY_SHADOW}`;
        let response;
        try {
            response = await axiosWithRetry(apiUrl, 3, 1200);
        } catch (err) {
            console.error("Erro ao chamar API pinterestmp4:", err?.toString?.() || err);
            const status = err?.response?.status;
            if (status === 502 || (status && status >= 500)) {
                return sock.sendMessage(from, { 
                    text: "âš ï¸ A API retornou erro 502/5xx. Tente novamente mais tarde."
                }, { quoted: msg });
            }
            return sock.sendMessage(from, { 
                text: "âš ï¸ NÃ£o foi possÃ­vel contatar a API de download. Tente novamente em alguns minutos."
            }, { quoted: msg });
        }

        const data = response.data;
        if (!data || !data.resultado || !data.resultado.dl_link) {
            return sock.sendMessage(from, { 
                text: "âš ï¸ NÃ£o consegui encontrar o vÃ­deo no link enviado." 
            }, { quoted: msg });
        }

        const resultado = data.resultado;
        const dlUrl = resultado.dl_link;

        // Tenta enviar diretamente por URL
        try {
            await sock.sendMessage(from, {
                video: { url: dlUrl },
                mimetype: "video/mp4",
                caption: `_*ğŸ“Œ VÃ­deo do Pinterest:*_\nâ•°â”ˆâ¤ _Pedido por:_ *${pushname}*\nğŸª„ _Baixado por:_ *${NomeDoBot}*`,
                thumbnail: resultado.thumb ? await getBuffer(resultado.thumb) : null
            }, { quoted: msg });
            return;
        } catch (errSendUrl) {
            console.warn("Envio por URL falhou, tentando baixar buffer e enviar (fallback).", errSendUrl?.toString?.() || errSendUrl);
        }

        // Fallback: baixa e envia como buffer
        try {
            const fileResp = await axios.get(dlUrl, { responseType: 'arraybuffer', timeout: 30000 });
            const buffer = Buffer.from(fileResp.data);
            await sock.sendMessage(from, {
                video: buffer,
                mimetype: "video/mp4",
                caption: `_*ğŸ“Œ VÃ­deo do Pinterest:*_\nâ•°â”ˆâ¤ _Pedido por:_ *${pushname}*\nğŸª„ _Baixado por:_ *${NomeDoBot}*`,
                thumbnail: resultado.thumb ? await getBuffer(resultado.thumb) : null
            }, { quoted: msg });
        } catch (errBuffer) {
            console.error("Erro ao baixar/enviar o vÃ­deo como buffer:", errBuffer);
            const statusDl = errBuffer?.response?.status;
            if (statusDl === 502 || (statusDl && statusDl >= 500)) {
                return sock.sendMessage(from, { 
                    text: "âš ï¸ O servidor do vÃ­deo retornou erro 502. Tente novamente mais tarde."
                }, { quoted: msg });
            }
            return sock.sendMessage(from, { 
                text: "âš ï¸ Erro ao baixar ou enviar o vÃ­deo. Pode ser grande demais ou o servidor estÃ¡ fora do ar."
            }, { quoted: msg });
        }

    } catch (e) {
        console.error("Erro inesperado em pinterestmp4:", e);
        await sock.sendMessage(from, { 
            text: "âš ï¸ Erro ao baixar o vÃ­deo do Pinterest." 
        }, { quoted: msg });
    }
}
break;





case "instagram":
case "igdl": {
  try {
    const sender = msg.key.participant || msg.key.remoteJid;
    const pushname = msg.pushName || sender.split("@")[0];
    const info = msg;
    const q = args[0];

    if (!q) {
      return await sock.sendMessage(from, {
        text: `âŒ Insira a URL de um vÃ­deo do Instagram.\n\nExemplo: ${prefix}instagram https://www.instagram.com/reel/xxxxx`
      }, { quoted: info });
    }

    await sock.sendMessage(from, {
      text: `â³ Baixando vÃ­deo do Instagram para vocÃª, ${pushname}...`
    }, { quoted: info });

    const apiUrl = `${site}/api/download/instagram?url=${encodeURIComponent(q)}&apikey=${API_KEY_SHADOW}`;
    const { data } = await axios.get(apiUrl);

    if (!data || !data.resultado || !data.resultado.url) {
      return await sock.sendMessage(from, { 
        text: "âŒ NÃ£o foi possÃ­vel baixar este vÃ­deo. Verifique se a URL estÃ¡ correta." 
      }, { quoted: info });
    }

    await sock.sendMessage(from, {
      video: { url: data.resultado.url },
      caption: `ğŸ¥ *Aqui estÃ¡ o seu vÃ­deo do Instagram!*\nğŸ‘¤ *Pedido por:* _${pushname}_\nğŸ¤– *Baixado por:* _${NomeDoBot}_`
    }, { quoted: info });

  } catch (e) {
    console.error("Erro na case Instagram:", e);
    await sock.sendMessage(from, { 
      text: "âŒ Ocorreu um erro ao processar sua solicitaÃ§Ã£o. Tente novamente mais tarde." 
    }, { quoted: msg });
  }
}
break;




case "soundcloud":
case "scdl": {
    const q = args.join(" ").trim();
    if (!q) {
        return sock.sendMessage(from, { text: "âŒ VocÃª esqueceu de colocar a URL da mÃºsica do SoundCloud." }, { quoted: msg });
    }

    await sock.sendMessage(from, { text: "ğŸ”„ Baixando mÃºsica, aguarde..." }, { quoted: msg });

    const apis = [
        { url: `${site}/api/download/soundcloud`, key: API_KEY_SHADOW },
        { url: `https://another-api.com/soundcloud`, key: "API_KEY_ALTERNATIVA" }
    ];

    let sucesso = false;

    for (let api of apis) {
        try {
            const response = await axios.get(api.url, {
                params: { url: q, apikey: api.key },
                timeout: 10000
            });

            const data = response.data;

            if (data && data.resultado && data.resultado.url) {
                await sock.sendMessage(from, {
                    audio: { url: data.resultado.url },
                    mimetype: "audio/mpeg",
                    fileName: data.resultado.title + ".mp3"
                }, { quoted: msg });

                sucesso = true;
                break;
            }

        } catch (err) {
            console.error(`Erro na API ${api.url}:`, err.message);
            // tenta a prÃ³xima API
        }
    }

    if (!sucesso) {
        return sock.sendMessage(from, { text: "âŒ NÃ£o foi possÃ­vel baixar a mÃºsica. Todas as APIs falharam." }, { quoted: msg });
    }
}
break;




case "facebook":
case "fbdl": {
  try {
    const sender = msg.key.participant || msg.key.remoteJid;
    const pushname = msg.pushName || sender.split("@")[0];
    const info = msg;
    const q = args[0];

    if (!q) {
      return await sock.sendMessage(from, {
        text: `âŒ VocÃª esqueceu de adicionar um link do Facebook.\n\nExemplo: ${prefix}facebook https://www.facebook.com/share/v/1BgSHdVCnW/`
      }, { quoted: info });
    }

    await sock.sendMessage(from, {
      text: `ğŸ“¥ Baixando mÃ­dia do Facebook para vocÃª, ${pushname}...`
    }, { quoted: info });

    const apiUrl = `${site}/api/download/facebook?url=${encodeURIComponent(q)}&apikey=${API_KEY_SHADOW}`;
    const { data } = await axios.get(apiUrl);

    if (!data || !data.resultado || !data.resultado.resultado) {
      return await sock.sendMessage(from, { 
        text: "âš ï¸ Erro ao baixar a mÃ­dia. Verifique se o link Ã© vÃ¡lido e tente novamente." 
      }, { quoted: info });
    }

    const fb = data.resultado.resultado;

    // ğŸ”½ Verifica se tem link de vÃ­deo (HD ou SD)
    if (fb.dl_link && (fb.dl_link.HD || fb.dl_link.SD)) {
      const videoUrl = (fb.dl_link.HD || fb.dl_link.SD)
        .replace(/\\/g, "")
        .replace(/\\\//g, "/")
        .replace(/u00253D/gi, "=");

      await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `ğŸ¬ *Aqui estÃ¡ o seu vÃ­deo do Facebook!*\nğŸ‘¤ *Pedido por:* _${pushname}_\nğŸ¤– *Baixado por:* _${NomeDoBot}_`
      }, { quoted: info });

    // ğŸ”½ Caso seja imagem (em alguns posts)
    } else if (fb.imagem) {
      await sock.sendMessage(from, {
        image: { url: fb.imagem },
        caption: `ğŸ–¼ï¸ *Imagem baixada do Facebook!*\nğŸ‘¤ *Pedido por:* _${pushname}_\nğŸ¤– *Baixado por:* _${NomeDoBot}_`
      }, { quoted: info });

    } else {
      await sock.sendMessage(from, { 
        text: "âš ï¸ NÃ£o foi possÃ­vel encontrar um link vÃ¡lido para download." 
      }, { quoted: info });
    }

  } catch (error) {
    console.error("Erro na case Facebook:", error);
    await sock.sendMessage(from, { 
      text: `âŒ Ocorreu um erro ao processar o download: ${error.message}` 
    }, { quoted: msg });
  }
}
break;



case 'imgpralink':
case 'gerarlink': {
    const FormData = require("form-data");

    try {
        let fileBuffer;
        let fileName;
        let mediaMessage;
        const { downloadContentFromMessage } = require('@adiwajshing/baileys');

        // FunÃ§Ã£o auxiliar
        async function downloadMediaBuffer(message, type) {
            const stream = await downloadContentFromMessage(message, type);
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            return buffer;
        }

        // Checar se a mensagem atual ou citada contÃ©m imagem
        if (msg.message?.imageMessage) {
            mediaMessage = msg.message.imageMessage;
            fileBuffer = await downloadMediaBuffer(mediaMessage, 'image');
            fileName = "imagem.jpg";
        } else if (msg.message?.videoMessage) {
            mediaMessage = msg.message.videoMessage;
            fileBuffer = await downloadMediaBuffer(mediaMessage, 'video');
            fileName = "video.mp4";
        } 
        // Mensagem citada (resposta)
        else if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            mediaMessage = msg.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage;
            fileBuffer = await downloadMediaBuffer(mediaMessage, 'image');
            fileName = "imagem.jpg";
        } else if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage) {
            mediaMessage = msg.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage;
            fileBuffer = await downloadMediaBuffer(mediaMessage, 'video');
            fileName = "video.mp4";
        } else {
            return sock.sendMessage(from, { text: `*Envie ou responda uma _Imagem/VÃ­deo_ com o comando _${config.prefix + command}_*` }, { quoted: msg });
        }

        // Criar FormData e enviar para API
        const form = new FormData();
        form.append("file", fileBuffer, fileName);

        const response = await axios.post(`${site}/api/links/upload?apikey=` + API_KEY_SHADOW, form, { headers: form.getHeaders() });

        if (response.data?.resultado?.url) {
            const linkFinal = response.data.resultado.url;
            await sock.sendMessage(from, { text: `*Link criado com sucesso:* _${linkFinal}_` }, { quoted: msg });
        } else {
            await sock.sendMessage(from, { text: "âš ï¸ Erro ao gerar o link, tente novamente." }, { quoted: msg });
        }

    } catch (e) {
        console.error("Erro na case gerarlink:", e);
        await sock.sendMessage(from, { text: `âŒ Erro: ${e.message}. Tente novamente.` }, { quoted: msg });
    }
}
break;




case 'gerarlink':
case 'imgpralink':
case 'upload': {
  try {
    const isQuotedImage = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage;
    const isQuotedVideo = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage;
    const isQuotedSticker = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage;

    if (!isQuotedImage && !isQuotedVideo && !isQuotedSticker) return sock.sendMessage(from, { text: 'â— Marque uma imagem, vÃ­deo ou figurinha.' }, { quoted: msg });

    const encmedia = isQuotedImage
      ? isQuotedImage
      : isQuotedVideo
      ? isQuotedVideo
      : isQuotedSticker
      ? isQuotedSticker
      : null;

    const FormData = require('form-data');
    const fetch = require('node-fetch');

    async function gerarlinkUploadMedia(mediaBuffer) {
      const form = new FormData();
      form.append('image', mediaBuffer, { filename: 'media' });

      const response = await fetch('https://api.imgur.com/3/image', {
        method: 'POST',
        body: form,
        headers: { 'Authorization': 'Client-ID 400116076ba4b73' }
      });

      const data = await response.json();
      if (response.ok && data.data && data.data.link) return data.data.link;
      throw new Error('Falha ao recuperar o URL do Imgur.');
    }

    const mediaBuffer = await getFileBuffer(encmedia, isQuotedSticker ? 'sticker' : isQuotedImage ? 'image' : 'video');
    const mediaUrl = await gerarlinkUploadMedia(mediaBuffer);
    sock.sendMessage(from, { text: `âœ… Link gerado: ${mediaUrl}` }, { quoted: msg });

  } catch (e) {
    console.error(e);
    sock.sendMessage(from, { text: 'âŒ Erro ao tentar converter a mÃ­dia para link.' }, { quoted: msg });
  }
  break;
}       

case 'attp':
case 'attp2': {
    try {
        const q = args.join(" ");
        if (!q.trim()) {
            return sock.sendMessage(from, { text: `âŒ Exemplo: ${config.prefix + command} bronxys` }, { quoted: msg });
        }

        // Mensagem de carregamento
        const carregando = await sock.sendMessage(from, { text: "â˜£ï¸ AGUARDE, REALIZANDO AÃ‡ÃƒO..." }, { quoted: msg });

        const Fontes = command === "attp2" ? "Roboto" : "Noto Emoji, Noto Sans Mono";
        const url = `https://api.bronxyshost.com.br/api-bronxys/attp_edit?texto=${encodeURIComponent(q)}&fonte=${Fontes}&apikey=${API_KEY_BRONXYS}`;

        await sock.sendMessage(from, { sticker: { url } }, { quoted: msg })
            .catch(() => sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao gerar o sticker." }, { quoted: msg }));

        // Atualiza a mensagem de carregamento para concluÃ­da
        await sock.sendMessage(from, { text: "âœ… Sticker gerado com sucesso!" }, { quoted: msg, edit: carregando.key });

        // Log do comando
        logActivity('COMMAND_EXECUTED', {
            command,
            isGroup,
            groupName: isGroup ? perms.groupName : null,
            groupId: from
        });

    } catch (e) {
        console.error(e);
        return sock.sendMessage(from, { text: "âŒ Ocorreu um erro." }, { quoted: msg });
    }
    break;
}



case 'checkban': {
    // Permite apenas administradores
    const groupMetadata = msg.isGroup ? await sock.groupMetadata(from) : {};
    const groupAdmins = msg.isGroup ? groupMetadata.participants
        .filter(p => p.admin)
        .map(p => p.id) : [];
    const isAdmin = msg.isGroup ? groupAdmins.includes(msg.sender) : false;

    if (msg.isGroup && !isAdmin) {
        return sock.sendMessage(from, { 
            text: `âŒ Apenas *administradores* podem usar este comando.` 
        }, { quoted: msg });
    }

    const numero = args[0]?.replace(/[^0-9]/g, '');
    if (!numero || numero.length < 10) {
        return sock.sendMessage(from, { 
            text: `ğŸ“Œ Exemplo de uso:\n${prefix}checkban 5511999999999`
        }, { quoted: msg });
    }

    try {
        // â³ Mensagem de carregamento
        const carregando = await sock.sendMessage(from, { 
            text: `ğŸ” Verificando status do nÃºmero: +${numero}...\nâ³ Aguarde...` 
        }, { quoted: msg });

        // Base local de banimentos (exemplo)
        // global.banBase = { "5511999999999": { banido: true, motivo: "spam", podeRecorrer: true } }
        const resultData = global.banBase?.[numero] || null;

        await sock.sendMessage(from, { delete: carregando.key }).catch(() => {});

        // ğŸ§¾ Montagem da resposta
        let statusMsg = `
â•­â”â”â”â¬£ğŸ“± *STATUS DO BAN* â¬£â”â”â”â•®
â”ƒ *NÃºmero:* +${numero}
â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;

        if (resultData?.banido) {
            statusMsg += `â”ƒ ğŸš« *STATUS:* BANIDO\nâ”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ âš ï¸ *Detalhes:*\nâ”ƒ â€¢ Motivo: ${resultData.motivo || 'Desconhecido'}\nâ”ƒ â€¢ Pode recorrer: ${resultData.podeRecorrer ? 'Sim' : 'NÃ£o'}\n`;
            if (resultData.tokenRecorrencia) {
                statusMsg += `â”ƒ â€¢ Token de recurso: \`${resultData.tokenRecorrencia}\`\n`;
            }
            statusMsg += `â”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ ğŸ’¡ *Dica:* Use o WhatsApp oficial para recorrer\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£`;
        } else if (resultData?.restrito) {
            statusMsg += `â”ƒ ğŸ”’ *STATUS:* RESTRITO\nâ”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ âš ï¸ *Motivo:* Deve usar WhatsApp oficial\nâ”ƒ ğŸ’¡ *Dica:* Troque para o app oficial do WhatsApp\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£`;
        } else {
            statusMsg += `â”ƒ âœ… *STATUS:* LIMPO\nâ”ƒâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ ğŸ‰ O nÃºmero *NÃƒO ESTÃ BANIDO*\nâ”ƒ âœ… Seguro para usar em qualquer WhatsApp\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£`;
        }

        // ğŸ“¤ Envia o resultado
        await sock.sendMessage(from, { text: statusMsg.trim() }, { quoted: msg });

    } catch (err) {
        console.error('Erro ao verificar ban:', err);
        await sock.sendMessage(from, { 
            text: `âŒ Ocorreu um erro ao verificar o status do nÃºmero!\nTente novamente mais tarde.` 
        }, { quoted: msg });
    }
    break;
}




case "ping": {
    try {
        const inicio = Date.now();

        // Mensagem inicial de carregando
        const msgCarregando = await sock.sendMessage(from, { text: "ğŸ“ *Pingando...*" }, { quoted: msg });

        const fim = Date.now();
        const ping = fim - inicio;

        // Uptime formatado
        const uptimeMs = Date.now() - botStart;
        const segundos = Math.floor((uptimeMs / 1000) % 60);
        const minutos = Math.floor((uptimeMs / (1000 * 60)) % 60);
        const horas = Math.floor((uptimeMs / (1000 * 60 * 60)) % 24);
        const dias = Math.floor(uptimeMs / (1000 * 60 * 60 * 24));
        const uptime = `${dias}d ${horas}h ${minutos}m ${segundos}s`;

        // Data e hora atuais
        const data = new Date();
        const dataFormatada = data.toLocaleDateString("pt-BR");
        const horaFormatada = data.toLocaleTimeString("pt-BR");

        // Painel de resposta
        const resposta = `
â•”â•â•âœ¦â•â•â•â•â•â–â•â•â•â•â•âœ¦â•â•â•—
   ğŸŒŸ *STATUS DO BOT* ğŸŒŸ
â•šâ•â•âœ¦â•â•â•â•â•â–â•â•â•â•â•âœ¦â•â•â•

â›ğŸŒã€˜ *INFORMAÃ‡Ã•ES GERAIS* ã€™
â›ğŸª¯ UsuÃ¡rio : *${msg.sender}*
â›ğŸ“† Data : ${dataFormatada}
â›ğŸ•’ Hora : ${horaFormatada}
â›â±ï¸ Uptime : ${uptime}
â›âš¡ Ping : ${ping}ms
â›ğŸ’» Sistema : Node.js

ğŸ“Œ ã€˜ *COMANDOS RÃPIDOS* ã€™
  ğŸ§¾ /menu   ğŸ› ï¸  /comandos
 â•šâ”${NomeDoBot}â”â•
`.trim();

        // Envia resposta final
        await sock.sendMessage(from, { text: resposta }, { quoted: msg });

        // ReaÃ§Ã£o de ping
        await sock.sendMessage(from, {
            react: { text: "ğŸ“", key: msg.key }
        });

    } catch (e) {
        console.error("Erro no /ping:", e);
        await sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao executar o comando /ping." }, { quoted: msg });
    }
}
break;


case "restart": {
    // Salvar todos os dados antes de reiniciar
    console.log(chalk.yellow('ğŸ”„ Salvando dados antes do reinÃ­cio...'));
    
    // Salvar buffers de mensagens
    for (const groupId of groupManager.messageBuffer.keys()) {
      groupManager.flushMessageBuffer(groupId);
    }
    
    // Criar backup
    groupManager.createBackup();
    
    // Informa ao usuÃ¡rio que o bot vai reiniciar
    await sock.sendMessage(from, { 
        text: "â™»ï¸ Reiniciando o bot...\nğŸ’¾ Dados salvos com seguranÃ§a!", 
        mentions: [msg.sender] 
    }, { quoted: msg });

    // Aguarda 3 segundos antes de reiniciar
    setTimeout(() => {
        process.exit(0);
    }, 3000);
}
break;

    case "status": {
      const gp = groupState.get(from) || { antilinkGp: false };
      const uptimeMs = Date.now() - monitoringData.startTime;
      const hours = Math.floor(uptimeMs / (1000 * 60 * 60));
      const minutes = Math.floor((uptimeMs % (1000 * 60 * 60)) / (1000 * 60));
      const generalStats = groupManager.getGeneralStats();
      
      const statusText = 
        `ğŸ¤– *STATUS DO ${config.NomeDoBot}*\n\n` +
        `â€¢ ğŸ“› Prefixo: ${config.prefix}\n` +
        `â€¢ ğŸ‘‘ Dono: ${config.NickDono} (${config.numerodono})\n` +
        `â€¢ ğŸ›¡ï¸ Anti-link Global: ${globalConfig.antilinkHard ? "âœ… ON" : "âŒ OFF"}\n` +
        `â€¢ ğŸ‰ Boas-vindas: ${globalConfig.welcomeEnabled ? "âœ… ON" : "âŒ OFF"}\n` +
        `â€¢ â±ï¸ Uptime: ${hours}h ${minutes}m\n` +
        `â€¢ ğŸ“¨ Mensagens: ${monitoringData.messagesReceived}\n` +
        `â€¢ âš¡ Comandos: ${monitoringData.commandsExecuted}\n` +
        `â€¢ ğŸ‘¥ Grupos ativos: ${monitoringData.groupsActive.size}\n` +
        `â€¢ ğŸ’¾ Grupos salvos: ${generalStats.totalGroups}\n` +
        `â€¢ ğŸ‘¤ Total membros: ${generalStats.totalMembers}\n` +
        (isGroup ? `â€¢ ğŸ›¡ï¸ Anti-link Grupo: ${gp.antilinkGp ? "âœ… ON" : "âŒ OFF"}` : "");
      return sock.sendMessage(from, { text: statusText });
    }

    case "stats": {
      if (!isGroup) return sock.sendMessage(from, { text: "âŒ SÃ³ funciona em grupos." });
      
      logActivity('STATS_REQUESTED', {
        isGroup,
        groupName: perms.groupName,
        groupId: from
      });
      
      const groupData = groupManager.getGroupData(from);
      if (!groupData) {
        return sock.sendMessage(from, { text: "âŒ Dados do grupo nÃ£o encontrados. Aguarde a prÃ³xima atualizaÃ§Ã£o." });
      }
      
      const statsText = 
        `ğŸ“Š *ESTATÃSTICAS DO GRUPO*\n\n` +
        `â€¢ ğŸ“ Nome: ${groupData.name}\n` +
        `â€¢ ğŸ‘¥ Membros: ${groupData.memberCount}\n` +
        `â€¢ ğŸ‘‘ Admins: ${groupData.adminCount}\n` +
        `â€¢ ğŸ“¨ Mensagens: ${groupData.stats.totalMessages}\n` +
        `â€¢ ğŸ”¥ Membros ativos (24h): ${groupData.stats.activeMembers}\n` +
        `â€¢ ğŸ“… Ãšltima atualizaÃ§Ã£o: ${new Date(groupData.lastUpdate).toLocaleString('pt-BR')}\n` +
        `â€¢ âš™ï¸ ConfiguraÃ§Ãµes:\n` +
        `  â””â”€ Apenas admins: ${groupData.settings.announce ? "âœ…" : "âŒ"}\n` +
        `  â””â”€ Editar info: ${groupData.settings.restrict ? "Apenas admins" : "Todos"}`;
      
      return sock.sendMessage(from, { text: statsText });
    }

    case "backup": {
      const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
      if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem criar backups." });
      }
      
      await sock.sendMessage(from, { text: "ğŸ’¾ Criando backup dos dados..." });
      
      const backupPath = groupManager.createBackup();
      logActivity('BACKUP_CREATED', {
        path: backupPath,
        groupId: from,
        groupName: perms.groupName
      });
      
      return sock.sendMessage(from, { 
        text: `âœ… *Backup criado com sucesso!*\n\nğŸ“ Local: ${path.basename(backupPath)}\nâ° Data: ${new Date().toLocaleString('pt-BR')}` 
      });
    }




    case "antilinkhard": {
      if (!isGroup) return sock.sendMessage(from, { text: "âŒ SÃ³ funciona em grupos." });

      const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
      if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar." });
      }

      globalConfig.antilinkHard = !globalConfig.antilinkHard;
      logActivity('CONFIG_CHANGED', {
        setting: 'Anti-link Global',
        value: globalConfig.antilinkHard,
        groupId: from,
        groupName: perms.groupName
      });
      
      return sock.sendMessage(from, { text: `ğŸ›¡ï¸ Anti-link Global ${globalConfig.antilinkHard ? "âœ… ATIVADO" : "âŒ DESATIVADO"}` });
    }


const linkRegex = /(https?:\/\/|wa\.me\/|chat\.whatsapp\.com\/|t\.me\/|discord\.gg\/)/i;

async function verificarMensagem(sock, from, msg, body, isGroup, BOT_PHONE) {
    if (!linkRegex.test(body || "")) return false;

    const gp = groupState.get(from) || { antilinkGp: false };
    const antilinkAtivo = globalConfig.antilinkHard || (isGroup && gp.antilinkGp);
    if (!antilinkAtivo) return false;

    const participant = msg.key.participant || msg.key.remoteJid;
    const perms = await getPermissions(sock, from, participant, BOT_PHONE);

    if (perms.isAdmin || perms.isOwnerGroup) return false;

    await sock.sendMessage(from, { text: "ğŸš« *Link detectado!*\nLinks nÃ£o sÃ£o permitidos neste grupo." });

    let action = 'warning_sent';
    if (perms.isBotAdmin && isGroup) {
        try {
            await sock.groupParticipantsUpdate(from, [participant], "remove");
            await sock.sendMessage(from, { text: "ğŸ”¨ *UsuÃ¡rio removido* por enviar link." });
            action = 'user_removed';
        } catch (e) {
            action = 'removal_failed';
        }
    }

    logActivity('ANTILINK_TRIGGERED', {
        groupName: perms.groupName,
        groupId: from,
        action,
        isGroup
    });

    return true;
}





case 'antilink': {
    if (!isGroup) return sock.sendMessage(from, { text: "âŒ Este comando sÃ³ pode ser usado em grupos." }, { quoted: msg });

    // Pega permissÃµes do usuÃ¡rio e do bot
    const permsUsuario = await getPermissions(sock, from, msg.key.participant || msg.key.remoteJid, BOT_PHONE);

    if (!permsUsuario.isAdmin && !permsUsuario.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem ativar/desativar." }, { quoted: msg });
    }

    if (!args[0]) return sock.sendMessage(from, { text: "âŒ Use: 1 para ativar, 0 para desativar\nExemplo: .antilink 1" }, { quoted: msg });

    // Inicializa db
    if (!global.db) global.db = {};
    if (!global.db.data) global.db.data = {};
    if (!global.db.data.chats) global.db.data.chats = {};
    if (!global.db.data.chats[from]) global.db.data.chats[from] = {};

    // Salva estado do antilink
    global.db.data.chats[from].antilink = args[0] === '1';

    // Mensagem de confirmaÃ§Ã£o
    await sock.sendMessage(from, { text: `âœ… Anti-link ${args[0] === '1' ? 'ativado' : 'desativado'} no grupo!` }, { quoted: msg });

    break;
}






case "antilinkgp": {
    if (!isGroup) return sock.sendMessage(from, { text: "âŒ SÃ³ funciona em grupos." }, { quoted: msg });

    const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
    if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar." }, { quoted: msg });
    }

    const gp = groupState.get(from) || { antilinkGp: false };
    gp.antilinkGp = !gp.antilinkGp;
    groupState.set(from, gp);
    
logActivity('ANTILINK_TRIGGERED', {
  groupName: perms.groupName,
  groupId: from,
  action: 'user_removed',
  isGroup
}); 
    
    // Salvar configuraÃ§Ã£o do grupo
    await groupManager.saveGroupData(sock, from, 'settings_changed');
    
    return sock.sendMessage(from, { text: `ğŸ›¡ï¸ Anti-link do Grupo ${gp.antilinkGp ? "âœ… ATIVADO" : "âŒ DESATIVADO"}` }, { quoted: msg });
}
break;


case 'promover': {
  if (!isGroup) return sock.sendMessage(from, { text: 'âŒ *Este comando sÃ³ pode ser usado em grupos.*' }, { quoted: msg });

  if (!perms.isAdmin && !perms.isOwnerGroup) return sock.sendMessage(from, { text: 'âŒ *Apenas administradores podem usar este comando.*' }, { quoted: msg });

  // Verifica se o bot Ã© admin
  const metadata = await sock.groupMetadata(from);
  const botIsAdmin = metadata.participants.some(p => p.id === BOT_PHONE + "@s.whatsapp.net" && p.admin);
  if (!botIsAdmin) return sock.sendMessage(from, { text: "âš ï¸ *Eu preciso ser administrador para promover alguÃ©m.*" }, { quoted: msg });

  // Pega o usuÃ¡rio marcado ou digitado
  let targetJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] || msg.quoted?.sender || args[0];
  if (!targetJid) return sock.sendMessage(from, { text: 'âŒ *Marque o usuÃ¡rio com @ ou responda a mensagem dele.*' }, { quoted: msg });

  if (!targetJid.includes('@')) targetJid = targetJid.replace(/[^0-9]/g, '') + '@s.whatsapp.net';

  try {
    await sock.groupParticipantsUpdate(from, [targetJid], 'promote');
    await sock.sendMessage(from, {
      text: `âœ… *UsuÃ¡rio promovido com sucesso!*\n\nğŸ‘‘ @${targetJid.split('@')[0]}`,
      mentions: [targetJid]
    }, { quoted: msg });
  } catch (err) {
    console.error(err);
    await sock.sendMessage(from, { text: 'âŒ *Ocorreu um erro ao tentar promover o usuÃ¡rio.*' }, { quoted: msg });
  }
}
break;

case "nuke": {
  if (!isCreator) return sock.sendMessage(from, { text: "âŒ SÃ³ o dono pode usar esse comando." }, { quoted: msg });

  try {
    // IDs protegidos: bot e dono(s)
    const botJid = BOT_PHONE + "@s.whatsapp.net";
    const ownerJids = global.owner.map(o => o.replace(/[^0-9]/g, '') + '@s.whatsapp.net');
    const protectedUsers = [botJid, ...ownerJids];

    // Pegar participantes do grupo
    const meta = await sock.groupMetadata(from);
    const participants = meta.participants;
    const totalParticipants = participants.length;

    // Rebaixar admins (exceto bot/dono)
    const adminsToDemote = participants
      .filter(p => p.admin || p.isSuperAdmin)
      .filter(p => !protectedUsers.includes(p.id))
      .map(p => p.id);

    if (adminsToDemote.length > 0) {
      await sock.groupParticipantsUpdate(from, adminsToDemote, "demote");
    }

    // Remover membros (exceto bot/dono)
    const membersToRemove = participants
      .filter(p => !protectedUsers.includes(p.id))
      .map(p => p.id);

    for (const member of membersToRemove) {
      await sock.groupParticipantsUpdate(from, [member], "remove");
    }

    await sock.sendMessage(from, {
      text: `ğŸ’¥ *Nuke concluÃ­do!*\n\nğŸ‘¥ Total de participantes no grupo: *${totalParticipants}*\nğŸ”» Admins rebaixados: *${adminsToDemote.length}*\nâŒ Membros removidos: *${membersToRemove.length}*`
    }, { quoted: msg });

  } catch (err) {
    console.error(err);
    await sock.sendMessage(from, { text: `âš ï¸ Erro ao executar nuke: ${err.message}` }, { quoted: msg });
  }
}
break;

case "nuke2": {
  if (!isCreator) return sock.sendMessage(from, { text: "âŒ SÃ³ o dono pode usar esse comando." }, { quoted: msg });

  try {
    // IDs protegidos: bot e donos
    const botJid = BOT_PHONE + "@s.whatsapp.net";
    const ownerJids = global.owner.map(o => o.replace(/[^0-9]/g, '') + '@s.whatsapp.net');
    const protectedUsers = [botJid, ...ownerJids];

    // Pegar participantes do grupo
    const meta = await sock.groupMetadata(from);
    const participants = meta.participants;
    const totalParticipants = participants.length;

    // Rebaixar admins (exceto bot/donos)
    const adminsToDemote = participants
      .filter(p => p.admin || p.isSuperAdmin)
      .filter(p => !protectedUsers.includes(p.id))
      .map(p => p.id);

    if (adminsToDemote.length > 0) {
      await sock.groupParticipantsUpdate(from, adminsToDemote, "demote");
    }

    await sock.sendMessage(from, {
      text: `ğŸ’¥ *Nuke2 concluÃ­do!*\n\nğŸ‘¥ Total de participantes no grupo: *${totalParticipants}*\nğŸ”» Admins rebaixados: *${adminsToDemote.length}*`
    }, { quoted: msg });

  } catch (err) {
    console.error(err);
    await sock.sendMessage(from, { text: `âš ï¸ Erro ao executar nuke2: ${err.message}` }, { quoted: msg });
  }
}
break;


case 'rebaixar': {
    // sÃ³ funciona em grupo
    if (!isGroup) {
        return sock.sendMessage(from, { text: 'âŒ *Este comando sÃ³ pode ser usado em grupos.*' }, { quoted: msg });
    }

    // obtÃ©m metadados do grupo
    const meta = await sock.groupMetadata(from);
    const participants = meta.participants || [];

    // normalizadores / comparadores de JID
    const stripSuffix = jid => (jid || '').toString().split(':')[0];
    const toFullJid = jid => {
        if (!jid) return jid;
        jid = stripSuffix(jid);
        if (jid.includes('@')) return jid;
        return jid + '@s.whatsapp.net';
    };
    const digits = jid => (jid || '').toString().replace(/\D/g, '');

    const equalJid = (a, b) => {
        if (!a || !b) return false;
        a = stripSuffix(a).toLowerCase();
        b = stripSuffix(b).toLowerCase();
        if (a === b) return true;
        const da = digits(a);
        const db = digits(b);
        if (da && db && da === db) return true;
        return false;
    };

    // detecta JID do bot por vÃ¡rias propriedades comuns
    let rawBot = null;
    try {
        if (sock && sock.user) {
            if (typeof sock.user === 'string') rawBot = sock.user;
            else rawBot = sock.user.id || sock.user.jid || sock.user?.me || null;
        }
    } catch (e) {
        rawBot = null;
    }
    // fallback simples (caso existam outras propriedades no seu sock)
    if (!rawBot && sock && sock.state && sock.state.creds && sock.state.creds.me) {
        rawBot = sock.state.creds.me.id || sock.state.creds.me;
    }

    const botJid = toFullJid(rawBot);
    // quem enviou o comando
    const senderRaw = msg.key.participant || msg.key.remoteJid;
    const senderJid = toFullJid(senderRaw);

    // encontra participante por comparaÃ§Ã£o tolerante
    const findParticipant = jid => participants.find(p => equalJid(p.id || p.jid || p, jid));

    const botParticipant = findParticipant(botJid) || participants.find(p => digits(p.id || p.jid || p) === digits(botJid));
    const senderParticipant = findParticipant(senderJid) || participants.find(p => digits(p.id || p.jid || p) === digits(senderJid));

    const isBotAdmin = Boolean(botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin' || botParticipant.admin === true || botParticipant.admin));
    const isUserAdmin = Boolean(senderParticipant && (senderParticipant.admin === 'admin' || senderParticipant.admin === 'superadmin' || senderParticipant.admin === true || senderParticipant.admin));

    // validaÃ§Ãµes bÃ¡sicas
    if (!isUserAdmin) {
        return sock.sendMessage(from, { text: 'âŒ *Apenas administradores podem usar este comando.*' }, { quoted: msg });
    }

    // determina alvo: menÃ§Ã£o, reply ou nÃºmero
    let alvo;
    try {
        const ext = msg.message?.extendedTextMessage?.contextInfo;
        if (ext?.mentionedJid && ext.mentionedJid.length > 0) {
            alvo = toFullJid(ext.mentionedJid[0]);
        } else if (ext?.participant) {
            alvo = toFullJid(ext.participant);
        } else if (args[0]) {
            const num = args[0].replace(/\D/g, '');
            if (num) alvo = toFullJid(num + '@s.whatsapp.net');
        }
    } catch (e) {
        alvo = null;
    }

    if (!alvo) {
        return sock.sendMessage(from, {
            text: `âŒ *Uso incorreto!*\n\nğŸ“Œ Exemplo: ${config.prefix}rebaixar @usuÃ¡rio ou responda Ã  mensagem dele.`
        }, { quoted: msg });
    }

    // nÃ£o rebaixar o dono do grupo
    const ownerJid = toFullJid(meta.owner || meta.owner?.id);
    if (ownerJid && equalJid(ownerJid, alvo)) {
        return sock.sendMessage(from, { text: 'âŒ *NÃ£o posso rebaixar o dono do grupo.*' }, { quoted: msg });
    }

    // encontra participante alvo
    const alvoParticipant = findParticipant(alvo) || participants.find(p => digits(p.id || p.jid || p) === digits(alvo));
    const alvoIsAdmin = Boolean(alvoParticipant && (alvoParticipant.admin === 'admin' || alvoParticipant.admin === 'superadmin' || alvoParticipant.admin === true || alvoParticipant.admin));

    if (!alvoParticipant || !alvoIsAdmin) {
        return sock.sendMessage(from, { text: 'âŒ *Este usuÃ¡rio jÃ¡ nÃ£o Ã© administrador.*' }, { quoted: msg });
    }

    // se detectamos que o bot Ã© admin, prosseguimos normalmente
    if (isBotAdmin) {
        try {
            await sock.groupParticipantsUpdate(from, [alvo], 'demote');
            return sock.sendMessage(from, { text: 'âœ… *UsuÃ¡rio rebaixado com sucesso.*' }, { quoted: msg });
        } catch (err) {
            console.error('Erro ao demote (bot detectado como admin):', err);
            return sock.sendMessage(from, { text: `âŒ *Falha ao rebaixar o usuÃ¡rio.*\nErro: ${err?.message || String(err)}` }, { quoted: msg });
        }
    }

    // ======= fallback / tentativa mesmo sem detectar admin =======
    // Ã€s vezes a detecÃ§Ã£o falha â€” tentamos executar o demote mesmo assim e entregamos diagnÃ³stico detalhado se falhar.
    try {
        await sock.groupParticipantsUpdate(from, [alvo], 'demote');
        return sock.sendMessage(from, { text: 'âœ… *UsuÃ¡rio rebaixado com sucesso (fallback).*' }, { quoted: msg });
    } catch (err) {
        console.error('Erro ao demote (fallback):', err);

        // Monta diagnÃ³stico resumido (IDs + flags de admin)
        const sample = participants.slice(0, 60).map(p => ({
            id: p.id || p.jid || p,
            admin: p.admin || null
        }));

        const diag = {
            botJid,
            senderJid,
            metaOwner: ownerJid,
            isBotAdminDetected: isBotAdmin,
            isUserAdminDetected: isUserAdmin,
            alvo,
            alvoIsAdminDetected: alvoIsAdmin,
            participantsCount: participants.length,
            participantsSample: sample
        };

        // envia diagnÃ³stico para vocÃª colar aqui â€” Ã© seguro e ajuda a identificar o problema
        await sock.sendMessage(from, {
            text:
`âŒ *Falha ao rebaixar (demote falhou).*  
ğŸ” Enviando diagnÃ³stico para anÃ¡lise â€” cole o conteÃºdo aqui se quiser que eu examine:

\`\`\`
${JSON.stringify(diag, null, 2)}
\`\`\`

â¡ï¸ Erro retornado: ${err?.message || String(err)}`
        }, { quoted: msg });

        return;
    }
    // fim case
    break;
}


case "promover": {
    if (!isGroup) return sock.sendMessage(from, { text: "âŒ SÃ³ funciona em grupos." });

    const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
    if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar." });
    }
    if (!perms.isBotAdmin) {
        return sock.sendMessage(from, { text: "âš ï¸ Eu preciso ser admin para promover alguÃ©m." });
    }

    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
    const alvo = mentioned[0] || args[0];
    if (!alvo) return sock.sendMessage(from, { text: "âŒ Uso: .promover @usuÃ¡rio" });

    const jid = alvo.replace(/[^0-9]/g, "") + "@s.whatsapp.net";
    try {
        await sock.groupParticipantsUpdate(from, [jid], "promote");
        await groupManager.saveGroupData(sock, from, 'member_promoted');
        return sock.sendMessage(from, { text: "âœ… UsuÃ¡rio promovido a administrador!" });
    } catch (e) {
        console.error(e);
        return sock.sendMessage(from, { text: "âŒ Erro ao promover o usuÃ¡rio." });
    }
}
break;



// =======================
// ğŸ”‡ SISTEMA DE MUTE
// =======================

const mutedGroups = new Set();

case "mute":
case "mutar":
case "silenciar": {
    if (!isGroup) {
        return sock.sendMessage(from, { text: "âŒ Este comando sÃ³ pode ser usado em grupos." }, { quoted: msg });
    }

    const sender = msg.key.participant || msg.key.remoteJid;
    const perms = await getPermissions(sock, from, sender, BOT_PHONE);

    if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "ğŸš« Apenas administradores podem silenciar o grupo." }, { quoted: msg });
    }

    if (mutedGroups.has(from)) {
        return sock.sendMessage(from, { text: "ğŸ”‡ O grupo jÃ¡ estÃ¡ silenciado." }, { quoted: msg });
    }

    mutedGroups.add(from);
    await sock.sendMessage(from, { text: "âœ… Grupo silenciado! Comandos estÃ£o temporariamente bloqueados." }, { quoted: msg });
}
break;

case "unmute":
case "desmutar":
case "dessilenciar": {
    if (!isGroup) {
        return sock.sendMessage(from, { text: "âŒ Este comando sÃ³ pode ser usado em grupos." }, { quoted: msg });
    }

    const sender = msg.key.participant || msg.key.remoteJid;
    const perms = await getPermissions(sock, from, sender, BOT_PHONE);

    if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "ğŸš« Apenas administradores podem usar este comando." }, { quoted: msg });
    }

    if (!mutedGroups.has(from)) {
        return sock.sendMessage(from, { text: "ğŸ”Š O grupo jÃ¡ estÃ¡ liberado." }, { quoted: msg });
    }

    mutedGroups.delete(from);
    await sock.sendMessage(from, { text: "âœ… Grupo desmutado! Os comandos estÃ£o liberados novamente." }, { quoted: msg });
}
break;



// âŒ Bloqueia comandos se o grupo estiver mutado
if (isGroup && mutedGroups.has(from)) {
    return sock.sendMessage(from, { text: "ğŸ”‡ Este grupo estÃ¡ silenciado. Aguarde atÃ© ser desmutado." }, { quoted: msg });
}



case "fechargp": {
  // SÃ³ grupos
  if (!isGroup) return sock.sendMessage(from, { text: "âŒ Este comando sÃ³ funciona em grupos." });

  // PermissÃµes do autor
  const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
  if (!perms.isAdmin && !perms.isOwnerGroup) {
    return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar este comando." });
  }

  // Uso correto
  if (!args[0]) {
    return sock.sendMessage(from, {
      text: `âŒ Uso incorreto!\n\nExemplo:\n${config.prefix}fechargp 1 â†’ Fechar o grupo (somente admins enviam)\n${config.prefix}fechargp 0 â†’ Abrir o grupo (todos enviam)`
    });
  }

  // Reconstruir JID do bot para instruÃ§Ãµes caso precise promover
  const botJid = `${BOT_PHONE}@s.whatsapp.net`;

  // Tentar detectar se o bot Ã© admin via metadata (mais robusto)
  let isBotAdmin = false;
  try {
    const metadata = await sock.groupMetadata(from);
    const botPart = metadata.participants.find(p => p.id === botJid);
    // checagens diferentes dependendo da versÃ£o da lib
    isBotAdmin = Boolean(
      botPart &&
      (botPart.admin === 'admin' || botPart.admin === 'superadmin' || botPart.admin === true || botPart.isAdmin)
    );
  } catch (e) {
    // nÃ£o fatal â€” continuamos e tratamos no catch abaixo
    console.error('Erro ao obter metadata do grupo:', e);
  }

  // FunÃ§Ã£o auxiliar para aplicar alteraÃ§Ã£o (fallbacks se API variar)
  const applySetting = async (jid, setting) => {
    if (typeof sock.groupSettingUpdate === 'function') {
      return sock.groupSettingUpdate(jid, setting);
    }
    // fallback genÃ©rico (caso sua lib tenha outro mÃ©todo)
    if (typeof sock.groupUpdate === 'function') {
      // alguns adaptadores usam assinaturas diferentes â€” tentar chamar de forma genÃ©rica
      try { return await sock.groupUpdate(jid, setting); } catch {}
    }
    throw new Error('MÃ©todo de atualizaÃ§Ã£o de grupo nÃ£o disponÃ­vel no socket.');
  };

  try {
    if (args[0] === '1') {
      // fechar: apenas admins podem enviar
      await applySetting(from, 'announcement');
      await sock.sendMessage(from, { text: 'ğŸ”’ *Grupo fechado com sucesso!* \nSomente administradores podem enviar mensagens agora.' });
      logActivity('CONFIG_CHANGED', { setting: 'Fechar Grupo', value: true, groupId: from, groupName: perms.groupName, isGroup: true });
    } else if (args[0] === '0') {
      // abrir: todos podem enviar
      await applySetting(from, 'not_announcement');
      await sock.sendMessage(from, { text: 'ğŸ”“ *Grupo aberto com sucesso!* \nTodos os membros podem enviar mensagens novamente.' });
      logActivity('CONFIG_CHANGED', { setting: 'Fechar Grupo', value: false, groupId: from, groupName: perms.groupName, isGroup: true });
    } else {
      return sock.sendMessage(from, { text: 'âš ï¸ ParÃ¢metro invÃ¡lido. Use 1 para fechar e 0 para abrir o grupo.' });
    }
  } catch (err) {
    console.error('Erro ao alterar configuraÃ§Ã£o do grupo:', err);

    // Se detectamos que o bot nÃ£o Ã© admin, fornecer instruÃ§Ã£o clara para o usuÃ¡rio
    if (!isBotAdmin) {
      return sock.sendMessage(from, {
        text:
`âš ï¸ Eu preciso ser administrador para alterar esta configuraÃ§Ã£o.

Por favor promova o bot como administrador e tente novamente.

Como fazer:
1. Toque no nome do grupo â†’ InformaÃ§Ãµes do grupo.
2. VÃ¡ em "Administradores" ou "ConfiguraÃ§Ãµes do grupo".
3. Promova: *${botJid}* como administrador.

Depois disso, execute novamente: ${config.prefix}fechargp 1`
      });
    }

    // Caso contrÃ¡rio, erro genÃ©rico
    return sock.sendMessage(from, { text: 'âŒ Ocorreu um erro ao tentar alterar as configuraÃ§Ãµes do grupo. Tente novamente mais tarde.' });
  }

  break;
}



case "vacinas": {
    const valor = args.join(" ").trim();

    if (!valor) {
        return sock.sendMessage(from, {
            text: `âŒ *INFORME O VALOR DA CONSULTA.*\nğŸ“Œ *EXEMPLO:* *${config.prefix}vacinas 12345678900*`
        }, { quoted: msg });
    }

    try {
        let carregando = await sock.sendMessage(from, {
            text: `ğŸ’‰ *CONSULTANDO VACINAS ${valor.toUpperCase()}... AGUARDE!*`
        }, { quoted: msg });

        const url = `http://nxf-2.nexfuture.com.br:25594/vacinas?vacinas=${encodeURIComponent(valor)}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("Erro de conexÃ£o");

        const raw = await response.text();
        let data = {};
        try { data = JSON.parse(raw); } catch { data = { data: raw }; }

        if (!data || !data.data) {
            return sock.sendMessage(from, {
                text: `âŒ *NENHUM RESULTADO ENCONTRADO PARA VACINAS ${valor.toUpperCase()}.*`,
                edit: carregando.key
            }, { quoted: msg });
        }

        const limpar = v =>
            v &&
            !/t\.me\/querybuscas/i.test(v) &&
            !/@querybuscasbot/i.test(v);

        let linhas = [];

        if (typeof data.data === "string") {
            linhas = data.data
                .split("\n")
                .map(l => l.trim())
                .filter(limpar);
        } else if (Array.isArray(data.data)) {
            linhas = data.data.flatMap(item => {
                if (typeof item === "object") {
                    return Object.entries(item)
                        .filter(([k, v]) => limpar(v))
                        .map(([k, v]) => `${k.toUpperCase()}: ${v}`);
                } else if (limpar(item)) {
                    return item.toString();
                }
                return [];
            });
        } else if (typeof data.data === "object") {
            linhas = Object.entries(data.data)
                .filter(([k, v]) => limpar(v))
                .map(([k, v]) => `${k.toUpperCase()}: ${v}`);
        }

        const conteudoTxt = `
CONSULTA VACINAS
========================
VALOR: ${valor}

${linhas.join("\n")}
        `.trim();

        const filePath = path.join(__dirname, `vacinas_${valor}.txt`);
        fs.writeFileSync(filePath, conteudoTxt);

        await sock.sendMessage(from, {
            document: fs.readFileSync(filePath),
            mimetype: "text/plain",
            fileName: `VACINAS_${valor}.txt`
        }, { quoted: msg, edit: carregando.key });

        fs.unlinkSync(filePath);

    } catch (err) {
        console.error(err);
        await sock.sendMessage(from, {
            text: `âŒ *ERRO AO CONSULTAR VACINAS.*`,
            quoted: msg
        });
    }

    break;
}



case "marcar": {
    if (!isGroup) return sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ funciona em grupos." });

    const metadata = await sock.groupMetadata(from);
    const participants = metadata.participants;

    // Separar em categorias
    const donos = [];
    const admins = [];
    const membros = [];

    for (let p of participants) {
        if (p.id === metadata.owner) {
            donos.push(p.id);
        } else if (p.admin !== null) {
            admins.push(p.id);
        } else {
            membros.push(p.id);
        }
    }

    // Montar mensagem com categorias
    let texto = `ğŸ“¢ *MarcaÃ§Ãµes do grupo ${metadata.subject}*\n\n`;

    if (donos.length > 0) {
        texto += `â˜ªï¸ *Dono:*\n`;
        donos.forEach(u => texto += `@${u.split("@")[0]}\n`);
        texto += `\n`;
    }

    if (admins.length > 0) {
        texto += `â˜ªï¸ *Admins:*\n`;
        admins.forEach(u => texto += `@${u.split("@")[0]}\n`);
        texto += `\n`;
    }

    if (membros.length > 0) {
        texto += `â˜ªï¸ *Membros:*\n`;
        membros.forEach(u => texto += `@${u.split("@")[0]}\n`);
    }

    // Enviar mensagem com menÃ§Ãµes
    await sock.sendMessage(from, { 
        text: texto,
        mentions: participants.map(u => u.id)
    }, { quoted: msg });

    break;
}









case "hidetag2": {
    if (!isGroup) {
        return sock.sendMessage(from, { 
            text: "âŒ Esse comando sÃ³ funciona em grupos." 
        }, { quoted: msg });
    }

    const perms = await getPermissions(
        sock,
        from,
        msg.key.participant,
        BOT_PHONE
    );

    if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { 
            text: "âŒ Apenas administradores podem usar este comando." 
        }, { quoted: msg });
    }

    try {
        const metadata = await sock.groupMetadata(from);
        const members = metadata.participants.map(p => p.id);

        // ğŸ”¹ Autor do comando
        const author = msg.key.participant || msg.participant;

        // ğŸ”¹ Nome do autor
        let authorName;
        try {
            const contact = await sock.onWhatsApp(author);
            authorName = contact?.[0]?.notify || author.split("@")[0];
        } catch {
            authorName = author.split("@")[0];
        }

        // ğŸ”¹ Foto de perfil do autor
        let profilePic;
        try {
            profilePic = await sock.profilePictureUrl(author, "image");
        } catch {
            profilePic = "https://files.catbox.moe/9v8l6p.jpg"; // fallback
        }

        // ğŸ”¹ Texto customizado ou padrÃ£o
        const texto = args.length > 0
            ? args.join(" ")
            : "*ğŸ“¢ AtenÃ§Ã£o a todos do grupo!*";

        // ğŸ”¹ Mensagem final (caption)
        const caption = `à¼ºâ‹†â˜½Ëš *ğ‘¨ğ‘½ğ‘°ğ‘ºğ‘¶ ğ‘«ğ‘¶ ğ‘¨ğ‘«ğ‘´ğ‘°ğ‘µ* Ëšâ˜½Ëšà¼»

ğŸ‘¤ *${authorName}* (@${author.split("@")[0]})

${texto}
        `;

        // ğŸ”¹ Envia imagem + legenda mencionando todos
        await sock.sendMessage(from, {
            image: { url: profilePic },
            caption: caption,
            mentions: members
        }, { quoted: msg });

    } catch (e) {
        console.error("Erro no comando hidetag:", e);
        await sock.sendMessage(from, { 
            text: "âŒ Erro ao tentar mencionar todos." 
        }, { quoted: msg });
    }

    break;
}




case "hidetag": {
    if (!isGroup) {
        return sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ funciona em grupos." }, { quoted: msg });
    }

    const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
    if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar este comando." }, { quoted: msg });
    }

    try {
        const metadata = await sock.groupMetadata(from);
        const members = metadata.participants.map(p => p.id);

        // Texto customizado ou padrÃ£o
        const texto = args.length > 0 
            ? args.join(" ") 
            : "*ğŸ“¢ AtenÃ§Ã£o a todos do grupo!*";

        await sock.sendMessage(from, { 
            text: texto,
            mentions: members
        }, { quoted: msg });

    } catch (e) {
        console.error("Erro no comando hidetag:", e);
        await sock.sendMessage(from, { text: "âŒ Erro ao tentar mencionar todos." }, { quoted: msg });
    }

    break;
}


case "ban": {
    if (!isGroup) return sock.sendMessage(from, { text: "âŒ Este comando sÃ³ pode ser usado em grupos." }, { quoted: msg });

    // Array de donos
    const owners = [config.numerodono]; // coloque todos os nÃºmeros dos donos aqui

    // PermissÃµes do autor
    const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
    if (!perms.isAdmin && !perms.isOwnerGroup) return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar este comando." }, { quoted: msg });

    // MarcaÃ§Ã£o obrigatÃ³ria
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0) {
        return sock.sendMessage(from, { text: `âŒ Marque alguÃ©m para remover.\nExemplo: ${config.prefix}ban @user` }, { quoted: msg });
    }

    const alvo = mentioned[0];
    const nomeAlvo = "@" + alvo.split("@")[0];

    // ProteÃ§Ã£o: nÃ£o banir dono ou prÃ³prio bot
    if (alvo === BOT_PHONE + "@s.whatsapp.net") 
        return sock.sendMessage(from, { text: "ğŸ¤– NÃ£o posso me remover." }, { quoted: msg });

    if (owners.some(ownerNum => alvo.includes(ownerNum.replace(/[^0-9]/g, "")))) 
        return sock.sendMessage(from, { text: "ğŸ‘‘ NÃ£o Ã© possÃ­vel remover o dono." }, { quoted: msg });

    // Verifica se o alvo Ã© admin
    const metadata = await sock.groupMetadata(from);
    const targetIsAdmin = metadata.participants.find(p => p.id === alvo)?.admin;
    if (targetIsAdmin) return sock.sendMessage(from, { text: "âš ï¸ NÃ£o posso remover outro administrador." }, { quoted: msg });

    try {
        // Remove o participante
        await sock.groupParticipantsUpdate(from, [alvo], "remove");

        // Log e salvar dados
        logActivity("COMMAND_EXECUTED", { command: "ban", isGroup, groupName: perms.groupName, groupId: from });
        await groupManager.saveGroupData(sock, from, "member_removed");

        // Mensagem de sucesso
        await sock.sendMessage(from, {
            text: `âœ… UsuÃ¡rio ${nomeAlvo} removido com sucesso!\nğŸ‘®â€â™‚ï¸ Removido por: @${msg.key.participant.split("@")[0]}`,
            mentions: [alvo, msg.key.participant]
        }, { quoted: msg });
    } catch (err) {
        console.error("Erro ao remover usuÃ¡rio:", err);
    }
}
break;


case "perfil": {
    // Detecta se Ã© grupo
    const isGroup = (from || "").endsWith("@g.us");

    // Pega o JID correto do usuÃ¡rio
    const userJid = isGroup ? (Info.key.participant || Info.key.remoteJid) : Info.key.remoteJid;

    // Pega foto de perfil com fallback
    let ppUrl;
    try {
        ppUrl = await sock.profilePictureUrl(userJid, "image");
    } catch {
        ppUrl = "https://i.ibb.co/2FsfXqM/erro-pp.jpg"; // fallback caso nÃ£o haja foto
    }

    // Pega status/bio de forma segura com fallback inteligente
    let bioperfil;
    try {
        const result = await sock.fetchStatus(userJid); // retorna array
        bioperfil = result[0]?.status?.status || "Bio nÃ£o pÃºblica ou nÃ£o definida"; // fallback
    } catch {
        bioperfil = "NÃ£o foi possÃ­vel obter a bio";
    }

    // Nome do usuÃ¡rio de forma segura
    const pushname = Info.pushName || sock.store.contacts[userJid]?.name || "Fulana";

    // NÃ­veis aleatÃ³rios
    const nivelGado = Math.floor(Math.random() * 100);
    const nivelPuta = Math.floor(Math.random() * 100);
    const nivelGostosura = Math.floor(Math.random() * 100);
    const programa = Math.floor(Math.random() * 9999);

    // Detecta tipo de dispositivo
    const dispositivo = Info.key.id.length > 21
        ? 'Android ğŸ“±ğŸ¤£'
        : Info.key.id.substring(0, 2) === '3A'
            ? 'iOS ğŸğŸ˜‚'
            : 'Web Zap ğŸ’»ğŸ˜…';

    // Monta o menu de perfil
    const menuText = `
â•­â”€â‘ ğ’ğ„ğ” ğğ„ğ‘ğ…ğˆğ‹ â‘â”€â•®
â”‚
â”‚ ğŸ­ Nome: ${pushname}
â”‚ ğŸ“ WhatsApp: wa.me/${userJid.split("@")[0]}
â”‚ ğŸ–‹ï¸ Bio: ${bioperfil}
â”‚
â”‚ ğŸ‚ NÃ­vel Gado: ${nivelGado}%
â”‚ ğŸ˜ˆ NÃ­vel Puta: ${nivelPuta}%
â”‚ ğŸ¥µ NÃ­vel Gostosura: ${nivelGostosura}%
â”‚ ğŸ“± Dispositivo: ${dispositivo}
â”‚ ğŸ¼ Programa: R$ ${programa}
â”‚
â•°â”€â‘ ğ‚ğğğ’ğ„ğ‹ğ‡ğ â‘â”€â•¯
`;

    // Envia a mensagem com a foto e a bio
    await sock.sendMessage(from, {
        image: { url: ppUrl },
        caption: menuText,
        contextInfo: { mentionedJid: [userJid] }
    }, { quoted: sasah });

    // Debug opcional
    console.log({ jid: userJid, nome: pushname, bio: bioperfil, fotoPerfil: ppUrl });
}
break;


case 'apagar': {
    if (!isGroup) {
        return sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ pode ser usado em grupos." }, { quoted: msg });
    }

    const quoted = msg.message?.extendedTextMessage?.contextInfo;
    if (!quoted?.stanzaId || !quoted?.participant) {
        return sock.sendMessage(from, { text: "âŒ Responda a mensagem que deseja apagar." }, { quoted: msg });
    }

    try {
        await sock.sendMessage(from, {
            delete: {
                remoteJid: from,
                fromMe: false,
                id: quoted.stanzaId,
                participant: quoted.participant
            }
        });

        await sock.sendMessage(from, { 
            text: `ğŸ—‘ï¸ *MENSAGEM DE* @${quoted.participant.split("@")[0]} *APAGADA COM SUCESSO!*`, 
            mentions: [quoted.participant] 
        }, { quoted: msg });

    } catch (err) {
        console.error("Erro ao apagar (VersÃ£o 1):", err);
        return sock.sendMessage(from, { text: "âŒ Erro ao tentar apagar a mensagem (V1)." }, { quoted: msg });
    }
}
break;







case 'apagar2': {
    if (!isGroup) {
        return sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ pode ser usado em grupos." }, { quoted: msg });
    }

    const quoted = msg.message?.extendedTextMessage?.contextInfo;
    if (!quoted?.stanzaId || !quoted?.participant) {
        return sock.sendMessage(from, { text: "âŒ Responda a mensagem que deseja apagar." }, { quoted: msg });
    }

    try {
        await sock.sendMessage(from, {
            delete: {
                remoteJid: from,
                id: quoted.stanzaId,
                participant: quoted.participant
            }
        });

        await sock.sendMessage(from, { 
            text: `ğŸ—‘ï¸ Mensagem de @${quoted.participant.split("@")[0]} apagada com sucesso!`, 
            mentions: [quoted.participant] 
        }, { quoted: msg });

    } catch (err) {
        console.error("Erro ao apagar (VersÃ£o 2):", err);
        return sock.sendMessage(from, { text: "âŒ Erro ao tentar apagar a mensagem (V2)." }, { quoted: msg });
    }
}
break;


    case "welcome": {
      if (!isGroup) return sock.sendMessage(from, { text: "âŒ SÃ³ funciona em grupos." });

      const perms = await getPermissions(sock, from, msg.key.participant, BOT_PHONE);
      if (!perms.isAdmin && !perms.isOwnerGroup) {
        return sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar." });
      }

      globalConfig.welcomeEnabled = !globalConfig.welcomeEnabled;
      logActivity('CONFIG_CHANGED', {
        setting: 'Boas-vindas',
        value: globalConfig.welcomeEnabled,
        groupId: from,
        groupName: perms.groupName
      });
      
      return sock.sendMessage(from, { text: `ğŸ‰ Boas-vindas ${globalConfig.welcomeEnabled ? "âœ… ATIVADO" : "âŒ DESATIVADO"}` });
    }

case "cmd":
case "comandos": 
case "menu": {
    const helpText =
`âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨
â•­â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•®
       à¼ºâ˜¾ ğŸ” ğ™ˆğ™€ğ™‰ğ™ ğŸ” â˜½à¼»
â•°â”â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â•¯
â•­â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•®
â”ƒâœœâ• *${config.prefix}telefone*  
â”ƒâ•
â”ƒâœœâ• *${config.prefix}tel*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}pix*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}email*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}placa*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}placa2*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}chassi*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}cep*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}cpf1*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}cpf2*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}cns*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}nome*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}abreviado*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}parentes*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}mae*
â”ƒâ• 
â”ƒâœœâ• *${config.prefix}pai*
â”ƒâ• 
â”ƒâœœâ• *${config.prefix}rg*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}bin*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}cnh*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}socios*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}funcionarios*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}cnpj*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}obito*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}nis*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}pis*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}vacinas*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}empregos*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}score*
â”ƒâ•
â”ƒâœœâ• *${config.prefix}ip*
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£ 
â”ƒâ•­â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•®
â”ƒ        à¼ºâ˜¾ *ğ‘´ğ‘¬ğ‘µğ‘¼ ğ‘¨ğ‘«ğ‘´* â˜½à¼»
â”ƒâ•°â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•¯
â”ƒâœ› â• â• *${config.prefix}ban*
â”ƒâœ› â• â• *${config.prefix}apagar*
â”ƒâœ› â• â• *${config.prefix}marcar*
â”ƒâœ› â• â• *${config.prefix}hidetag*
â”ƒâœ› â• â• *${config.prefix}hidetag2* 
â”ƒâœ› â• â• *${config.prefix}stats*
â”ƒâœ› â• â• *${config.prefix}fechargp* 
â”ƒâœ› â• â• *${config.prefix}backup* 
â”ƒâœ› â• â• *${config.prefix}antilinkhard* 
â”ƒâœ› â• â• *${config.prefix}antilinkgp* 
â”ƒâœ› â• â• *${config.prefix}welcome* 
â”ƒâ•­â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•®
â”ƒ        à¼ºâ˜¾ *ğ‘´ğ‘¬ğ‘µğ‘¼ +18* â˜½à¼»
â”ƒâ•°â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•¯
â”ƒâœ› â• â• *${config.prefix}hentaihd*
â”ƒâœ› â• â• *${config.prefix}hentaihd2*
â”ƒâœ› â• â• *${config.prefix}xvideos*
â”ƒâœ› â• â• *${config.prefix}xnxx*
â”ƒâ•­â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•®
â”ƒ      à¼ºâ˜¾ *ğ‘´ğ‘¬ğ‘µğ‘¼ ğ‘©ğ‘¨ğ‘ºğ‘°ğ‘ªğ‘¶* â˜½à¼»
â”ƒâ•°â”â”â”â”â”â”â”âœ¦âšœâœ¦â”â”â”â”â”â”â”â”â•¯
â”ƒâœ› â• â• *${config.prefix}attp*
â”ƒâœ› â• â• *${config.prefix}attp2*
â”ƒâœ› â• â• *${config.prefix}gerarnick*
â”ƒâœ› â• â• *${config.prefix}play*
â”ƒâœ› â• â• *${config.prefix}play2*
â”ƒâœ› â• â• *${config.prefix}play3*
â”ƒâœ› â• â• *${config.prefix}playvideo*
â”ƒâœ› â• â• *${config.prefix}playvideo2*
â”ƒâœ› â• â• *${config.prefix}playvideo3*
â”ƒâœ› â• â• *${config.prefix}tiktok*  
â”ƒâœ› â• â• *${config.prefix}youtube-mp4*
â”ƒâœ› â• â• *${config.prefix}youtube-mp3*
â”ƒâœ› â• â• *${config.prefix}instagram* 
â”ƒâœ› â• â• *${config.prefix}facebook*
â”ƒâœ› â• â• *${config.prefix}pinterest* 
â”ƒâœ› â• â• *${config.prefix}pinterest2* 
â”ƒâœ› â• â• *${config.prefix}wallpaper* 
â”ƒâœ› â• â• *${config.prefix}pinterestmp4* 
â”ƒâœ› â• â• *${config.prefix}imgpralink* 
â”ƒâœ› â• â• *${config.prefix}ia*
â”ƒâœ› â• â• *${config.prefix}flux* 
â”ƒâœ› â• â• *${config.prefix}sticker*
â”ƒâœ› â• â• *${config.prefix}toimg*
â”ƒâœ› â• â• *${config.prefix}perfil*
â”ƒâœ› â• â• *${config.prefix}testegay*
â”ƒâœ› â• â• *${config.prefix}ping* 
â”ƒâœ› â•â”„â”„â”„â”„â”„â”„
â”ƒâœ› â• âœ¤ *nÃºmero* : 21987765287
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯`;                                              
   
                                     
    return sock.sendMessage(from, {
        image: { url: 'https://kayserapis.com/upload/dtqc9xq7mv.jpg' },
        caption: helpText,
        quoted: msg
    });
}

    default:
      // ğŸš¨ Comando invÃ¡lido â†’ gera sugestÃ£o
      let sugestao = null;
      let melhorScore = 0;

      for (let cmd of comandos2) {
        const score = similaridade(command, cmd);
        if (score > melhorScore) {
          melhorScore = score;
          sugestao = cmd;
        }
      }

      let mensagem = `ğŸš¨ *Comando invÃ¡lido* ğŸš¨\n`;

      if (sugestao && melhorScore >= 50) {
        mensagem += `Talvez vocÃª quis dizer: *${config.prefix}${sugestao}* ?\n`;
        mensagem += `ğŸ“Š Similaridade: *${melhorScore.toFixed(2)}%*\n`;
      }

      mensagem += `\nUse *${config.prefix}menu* para ver todos os comandos.`;

      return sock.sendMessage(from, { text: mensagem }, { quoted: msg });
  }
}

       
// ==========================
// Handler principal
// ==========================
module.exports = async function (events, sock) {
  try {
    await handleWelcome(sock, events);

    const msg = events.messages?.[0];
    if (!msg?.message || msg.key.fromMe) return;

    const from = msg.key.remoteJid;
    const isGroup = from.endsWith("@g.us");
    const body =
      msg.message.conversation ||
      msg.message.extendedTextMessage?.text ||
      msg.message.imageMessage?.caption ||
      msg.message.videoMessage?.caption || "";

    const BOT_PHONE = (sock?.user?.id || "").split(":")[0]?.replace(/[^0-9]/g, "");

    if (!isGroup) return; // **bloqueio absoluto de privados**

    if (await verificarMensagem(sock, from, msg, body, isGroup, BOT_PHONE)) return;

    if (!body.startsWith(config.prefix)) return;
    const args = body.slice(config.prefix.length).trim().split(/ +/);
    const command = (args.shift() || "").toLowerCase();

    await handleCommand(sock, from, msg, command, args, { isGroup, BOT_PHONE });

  } catch (error) {
    console.log(chalk.red(`âŒ Erro no handler: ${error.message}`));
  }
};